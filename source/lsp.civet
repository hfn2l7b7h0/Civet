// Experimenting with transpiling to TS

import ts, {
  CompilerOptions
  ScriptTarget
} from "typescript"

const DefaultCompilerOptions : CompilerOptions =
  allowNonTsExtensions: true
  allowJs: true
  target: ts.ScriptTarget.Latest
  moduleResolution: ts.ModuleResolutionKind.NodeJs
  module: ts.ModuleKind.CommonJS
  allowSyntheticDefaultImports: true
  experimentalDecorators: true

const fileCache : Record<string, any> = {}

const createCompilerHost = (options: CompilerOptions, moduleSearchLocations : string[]) ->
  const fileExists = (fileName: string) : boolean ->
    return fileCache[fileName]?

  const readFile = (fileName: string) ->
    return fileCache[fileName]

  const getSourceFile = (fileName: string, languageVersion: ScriptTarget, onError: (message: string) => void ) ->
    const sourceText = ts.sys.readFile fileName

    if sourceText != undefined
      return ts.createSourceFile fileName, sourceText, languageVersion
    return

  const resolveModuleNames = (moduleNames, containingFile) ->
    resolvedModules = []

    for moduleName of moduleNames
      // try to use standard resolution
      const result = ts.resolveModuleName moduleName, containingFile, options, {
        fileExists,
        readFile
      }

      if result.resolvedModule
        resolvedModules.push(result.resolvedModule);
      else
        // check fallback locations, for simplicity assume that module at location
        // should be represented by '.d.ts' file
        for location of moduleSearchLocations
          modulePath = path.join(location, moduleName + ".d.ts")
          if fileExists(modulePath)
            resolvedModules.push({ resolvedFileName: modulePath })

    return resolvedModules

  return {
    getCompilationSettings: ->
      return options
    getSourceFile
    getDefaultLibFileName: ->
      return "lib.d.ts"
    writeFile: (fileName, content) ->
      fileCache[fileName] = content
    getCurrentDirectory: ->
      ts.sys.getCurrentDirectory()
    getDirectories: (path) ->
      ts.sys.getDirectories(path)
    getCanonicalFileName: (fileName) ->
      if ts.sys.useCaseSensitiveFileNames
        fileName
      else
        fileName.toLowerCase()
    getNewLine: ->
      ts.sys.newLine
    getScriptFileNames: ->
      Object.keys(fileCache)
    getScriptKind: (fileName) ->
      ts.ScriptKind.TS
    getScriptSnapshot: (fileName) ->
      content = fileCache[fileName]
      if content?
        ts.ScriptSnapshot.fromString(content)
      else
        return undefined
    getScriptVersion: (fileName) ->
      ""
    useCaseSensitiveFileNames: ->
      ts.sys.useCaseSensitiveFileNames
    fileExists
    readFile
    resolveModuleNames
  }

const host = createCompilerHost(DefaultCompilerOptions)
ts.createLanguageService(host)
