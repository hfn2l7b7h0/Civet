# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

Program
  Reset Init __ TopLevelStatement*:statements __ ->
    module.processProgram(statements)

    return $0

TopLevelStatement
  EOS? ModuleItem StatementDelimiter

# Expressions with If and Switch
ExtendedExpression
  # NOTE: Added IfExpression
  __ ExpressionizedStatement ->
    if ($1.length) {
      $2.children.splice(0, 0, ...$1)
    }
    return $2
  AssignmentExpression

ExpressionizedStatement
  DebuggerExpression
  IfExpression
  IterationExpression
  SwitchExpression
  ThrowExpression

# https://262.ecma-international.org/#prod-Expression
Expression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression (__ Comma AssignmentExpression)* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  OpenParen ArgumentList? ( __ Comma )? __ CloseParen
  # NOTE: Added spacing based implicit function application
  # Trailing (__ MemberExpressionRest)* is to capture trailing .someMethod and bind them at the right place
  ImplicitApplication

ArgumentsWithTrailingCallExpressions
  # Since this is recursive Arguments must consume input to avoid infinite recursion
  # NOTE: Do not allow trailing template literals to match
  TrackIndent (( Arguments ( &EOS Samedent !Backtick CallExpressionRest )* PopIndent ) / PopIndent) ->
    // No match, only restored indent
    if (!$2) return $skip
    return $2

# https://262.ecma-international.org/#prod-ArgumentList
ArgumentList
  # NOTE: Added nested arguments on separate new lines
  &EOS NestedArgumentList -> $2
  InlineArgumentExpressions

NestedArgumentList
  PushIndent NestedArgument*:args PopIndent ->
    if (args.length) return args
    return $skip

NestedArgument
  Nested InlineArgumentExpressions ParameterElementDelimiter

InlineArgumentExpressions
  # NOTE: Eliminated left recursion
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  ArgumentPart ( __ Comma TrailingComment* ArgumentPart )* ->
    if($2.length == 0) return $1
    return $0

ArgumentPart
  # Allow leading or trailing dots for argument splats
  DotDotDot ExtendedExpression
  ExtendedExpression DotDotDot? ->
    if ($2) {
      return [$2, $1]
    }
    return $1

ImplicitApplication
  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ApplicationStart ArgumentList InsertCloseParen

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  !EOS _:spacing !AdditionalReservedWords ->
    return module.insertTrimmingSpace(spacing, "(")
  # Nested application for nested objects
  # someMethod => someMethod({
  #   a: b          a: b
  #               })
  #
  # IndentedApplicationAllowed gets turned of inside if conditions and switch conditions to prevent
  # indentation based function application from being used inside them. It is a bit of a hack.
  IndentedApplicationAllowed &( EOS NestedPropertyDefinitions ) InsertOpenParen

IndentedApplicationAllowed
  "" ->
    if (module.suppressIndentedApplication) return $skip
    return

BinaryOpExpression
  UnaryExpression BinaryOpRHS* ->
    if ($2.length) {
      return module.processBinaryOpExpression($0)
    }

    return $1

BinaryOpRHS
  __ BinaryOp __ ( ParenthesizedAssignment / UnaryExpression / ExpressionizedStatement )

ParenthesizedAssignment
  InsertOpenParen ActualAssignment InsertCloseParen

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Merged AwaitExpression with UnaryOp
  # https://262.ecma-international.org/#prod-AwaitExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UpdateExpression:exp UnaryPostfix?:post ->
    // Handle "?" postfix
    if (post?.token === "?") {
      // v1.1 Can remove parens when unnecessary once exp returns a full AST node to determine if they are actually needed
      return ["(", pre, "(", exp, ") != null)"]
    }

    // Combine unary - to create negative numeric literals
    if (exp.type === "Literal") {
      if (pre.length === 1 && pre[0].token === "-") {
        exp.raw = `-${exp.raw}`
        exp.children.unshift(pre[0])
        if (post) exp.children.push(post)
        return exp
      }
    }

    if (exp.children) {
      exp.children.unshift(...pre)
      if (post) exp.children.push(post)
      return exp
    } else if (Array.isArray(exp)) {
      exp.unshift(...pre)
      if (post) exp.push(post)
      return exp
    } else {
      const result = [...pre, exp]
      if (post) result.push(post)
      return result
    }

  # NOTE: This is a little hacky to match CoffeeScript's behavior
  # https://coffeescript.org/#try:do%20x%20%2B%20y%0Ado%20x%20%3D%20y%0Ado%20-%3E%20x%20%3D%201
  CoffeeDoEnabled Do __:ws ( ( LeftHandSideExpression !( __ AssignmentOpSymbol ) ) / ArrowFunction / ExtendedExpression ):exp ->
    module.insertTrimmingSpace(ws, "")
    return ["(", ws, exp, ")()"]

UnaryPostfix
  QuestionMark
  ( __ As Type )+ -> { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryExpression
  LeftHandSideExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

UpdateExpressionSymbol
  ("++" / "--") ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  TrailingComment* AssignmentExpressionTail ->
    if ($1.length) {
      if ($2.children) {
        $2.children.splice(0, 0, ...$1)
        return $2
      }
      return $0
    }
    return $2
  __ AssignmentExpressionTail

AssignmentExpressionTail
  YieldExpression
  ArrowFunction
  ActualAssignment
  ConditionalExpression

# An assignment that actually includes an assignment operator, not just passing down to a ConditionalExpression
ActualAssignment
  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  ( __ LeftHandSideExpression __ AssignmentOp )+ ExtendedExpression ->
    let tail = [], i = 0, len = $1.length

    // Force parens around destructuring object assignments
    // Walk from left to right the minimal number of parens are added and enclose all destructured assignments
    // TODO: Could validate some lhs ecmascript rules here if we wanted to
    while (i < len) {
      const lastAssignment = $1[i++]
      const [,lhs,,op] = lastAssignment
      if (op.token !== "=") continue

      // Only wrap with one set of parens
      if (lhs.type === "ObjectExpression") {
        lhs.children.splice(0, 0, "(")
        tail.push(")")
        break
      }
    }

    // TODO: Handle optional assignment refs

    // Walk from right to left to handle splices
    i = len - 1
    while (i >= 0) {
      const lastAssignment = $1[i]

      if (lastAssignment[3].token === "=") {
        const lhs = lastAssignment[1]

        // Splice assignment
        if (Array.isArray(lhs) && lhs.length > 1) {
          const props = lhs[lhs.length-1]

          if (Array.isArray(props)) {
            const lastProp = props[props.length-1]

            // TODO: this is kind of bonkers
            if(lastProp.type === "SliceExpression") {
              const {start, end, children: c} = lastProp
              // TODO: don't lose as many source mappings
              c[0].token = ".splice("
              c[1] = start
              c[2] = ", "
              if (end)
                c[3] = [end, " - ", start]
              else
                c[3] = ["1/0"]
              c[4] = [", ...", $2]
              c[5] = ")"

              // Remove assignment token
              lastAssignment.pop()
              if (module.isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment.pop()
              // TODO: this only works for the last assignment, not multiple splice assignments, or splice assignments earlier in the chain
              if ($1.length > 1) {
                throw new Error("Not implemented yet! TODO: Handle multiple splice assignments")
              }
              return $1
            }
          }
        }
      }
      i--
    }

    // Gather all identifier names from the lhs array
    const names = $1.flatMap(([,l]) => l.names || [])

    return {
      type: "AssignmentExpression",
      children: [...$0, ...tail],
      names,
    }

# https://262.ecma-international.org/#prod-YieldExpression
YieldExpression
  Yield YieldTail

YieldTail
  &EOS
  # NOTE: Merged optional star
  ( TrailingComment* Star )? AssignmentExpression

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ( Async __ )? ArrowFunctionTail ->
    if ($1) $2.children.unshift($1)
    return $2

ArrowFunctionTail
  ThinArrowFunction
  Parameters:parameters ReturnTypeSuffix?:suffix FatArrow FatArrowBody:expOrBlock ->
    const isVoid = suffix?.children?.[1]?.[0]?.[1]?.token === "void"
    const isBlock = expOrBlock.type === "BlockStatement"
    if (module.config.implicitReturns && !isVoid && isBlock) {
      module.addImplicitReturns(expOrBlock)
    }

    return {
      type: "ArrowFunction",
      parameters,
      returnType: suffix,
      ts: false,
      block: expOrBlock,
      children: $0,
    }

FatArrow
  # Ensures at least one space before arrow
  __:ws "=>" ->
    if (!ws.length)
      return " =>"
    return $0

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  __ OpenBrace EOS NestedBlockStatements:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockStatements:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  AssignmentExpression
  EmptyBlock

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  ShortCircuitExpression TernaryRest? ->
    if ($2) {
      $2.unshift($1)
      return $2
    }
    return $1

TernaryRest
  # NOTE: Ternary `a ? b : c` is disabled if CoffeeScript binary existential `a ? b` is enabled
  !CoffeeBinaryExistentialEnabled __ QuestionMark ExtendedExpression __ Colon ExtendedExpression ->
    $0.shift()
    return $0

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  This
  Literal
  ArrayLiteral
  ObjectLiteral
  IdentifierReference # NOTE: Must be below ObjectLiteral for inline objects `a: 1, b: 2` to not be shadowed by matching the first identifier
  FunctionExpression
  ClassExpression
  RegularExpressionLiteral
  TemplateLiteral
  ParenthesizedExpression
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  JSXElement
  JSXFragment

# https://262.ecma-international.org/#prod-ParenthesizedExpression
ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen ExtendedExpression:exp __ CloseParen ->
    return {
      type: "ParenthesizedExpression",
      expression: exp,
      children: $0,
    }

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  ClassExpression

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Class ( BindingIdentifier )? ( __ ClassHeritage )? ClassBody

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  # ExtendsToken __ LeftHandSideExpression
  # NOTE: This is a subset of member expression that doesn't have spaced function application
  # TODO: there are some other LeftHandSideExpressions that are valid here but aren't yet supported (new, super, import expression)
  ExtendsToken __ MemberExpression

ExtendsToken
  # NOTE: Added "<" extends shorthand
  "<" ->
    return { $loc, token: "extends" }
  "extends" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __ OpenBrace (EOS NestedClassElements)? __ CloseBrace
  InsertOpenBrace EOS NestedClassElements InsertNewline InsertIndent InsertCloseBrace

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  # NOTE: Combined optional static and Method/Field definition
  (Static TrailingComment*)? ( MethodDefinition / FieldDefinition )
  # ClassStaticBlock
  Static BracedBlock

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # TODO: CoffeeCompat class method fields
  # name: (param1, param2) ->
  CoffeeClassesEnabled ClassElementName:id __ Colon __ AssignmentExpression:exp ->
    switch (exp.type) {
      // TODO: => functions
      case "FunctionExpression":
        // Remove "function" token
        exp.children.shift()
        exp.id.push(id)
        return exp
      default:
        return [id, " = ", exp]
    }

  # NOTE: Added readonly semantic equivalent of const field assignment
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertReadonly:r ClassElementName TypeSuffix? __ ConstAssignment:ca ExtendedExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return $0

  ClassElementName TypeSuffix? Initializer?

This
  "this" ->
    return { $loc, token: $1 }
  # NOTE: Added @identifier shorthand, also works for private identifiers
  At ( "#"? IdentifierName ) ->
    $1.token = "this."
    return $0
  # NOTE: Added '@' as a 'this' shorthand from CoffeeScript
  At ->
    $1.token = "this"
    return $1

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  # https://262.ecma-international.org/#prod-NewExpression
  # NOTE: Merged in NewExpression
  # NOTE: Changed to CallExpression to handle arguments
  # NOTE: Eliminated left recursion
  ( New !"." __ )* CallExpression ->
    if ($1.length) return $0
    return $2
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  "super" ArgumentsWithTrailingCallExpressions
  # NOTE: Using ExtendedExpression to allow for If/Switch expressions
  "import" __ OpenParen ExtendedExpression __ CloseParen
  MemberExpression CallExpressionRest* ->
    if ($2.length) return $0
    return $1

CallExpressionRest
  MemberExpressionRest
  TemplateLiteral
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  ( OptionalShorthand / NonNullAssertion )? ArgumentsWithTrailingCallExpressions

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  ( QuestionMark ( Dot / InsertDot ) )

NonNullAssertion
  "!" -> { ts: true, children: $1 }

# Reserved words that will prevent spaced function application
# ie: the 'of' in 'for x of ...'
AdditionalReservedWords
  /(of|then|when)(?!\p{ID_Continue}|[\u200C\u200D$])/

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  PrimaryExpression MemberExpressionRest* ->
    if ($2.length) return $0
    return $1
  SuperProperty
  MetaProperty

MemberExpressionRest
  # NOTE: Added shorthand x?[3] -> x?.[3]
  ( OptionalShorthand / NonNullAssertion )? MemberBracketContent ->
    if ($1) {
      // Optional followed by a slice expression
      if ($1.length === 2 && $2.type === "SliceExpression") {
        // Remove '.' from optional since it present in '.slice'
        $1.pop()
      }
      return $0
    }
    return $2
  # NOTE: Combined Optional and Property access
  # TODO: this doesn't yet work for arbitrarily deep nesting, only the first level
  ( &EOS IndentedFurther )? PropertyAccess ->
    if ($1) $2.children.unshift($1[1])
    return $2
  # NOTE: Added CoffeeScript :: prototype shorthand
  ( &EOS IndentedFurther )? "::" IdentifierName?:id ->
    if (id)
      return [".prototype.", id]
    return ".prototype"
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

# Handles indexing and slicing
MemberBracketContent
  OpenBracket ExtendedExpression ( __ ( DotDotDot / DotDot ) ExtendedExpression? )? __ CloseBracket ->
    // Some kind of slice
    if ($3) {
      // TODO: Comments here should make it into the output
      // const ws  = $3[0]
      const sep = $3[1]
      const end = $3[2]
      const inclusive = sep.token === ".."

      sep.token = ", "
      $1.token = ".slice("
      $5.token = ")"

      if (!end) {
        return {
          type: "SliceExpression",
          start: $2,
          end: undefined,
          children: [$1, $2, $4, $5]
        }
      }

      if (inclusive) {
        module.insertTrimmingSpace(end, "")
        return {
          type: "SliceExpression",
          start: $2,
          end: ["1 + ", end],
          children: [$1, $2, sep, ["1 + ", end, " || 1/0"], $4, $5]
        }
      }

      return {
        type: "SliceExpression",
        start: $2,
        end: end,
        children: [$1, $2, sep, end, $4, $5]
      }
    }

    // Regular index `[exp]`
    return $0

PropertyAccess
  ( QuestionMark / NonNullAssertion )? Dot ( IdentifierName / PrivateIdentifier ):id ->
    id.type = "PropertyAccess"
    id.children.unshift($2)
    if ($1) id.children.unshift($1)

    return id

SuperProperty
  "super[" ExtendedExpression __ CloseBracket

MetaProperty
  New Dot Target
  "import.meta" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  NonEmptyParameters
  "" ->
    return {
      type: "Parameters",
      children:[{$loc, token: "()"}],
      names: [],
    }

NonEmptyParameters
  # NOTE: BindingElement -> ParameterElement
  TypeParameters? OpenParen ParameterElement* FunctionRestParameter? __ CloseParen ->
    return {
      type: "Parameters",
      children: $0,
      names: $3.flatMap((p) => p.names),
    }

# https://262.ecma-international.org/#prod-FunctionRestParameter
FunctionRestParameter
  __ BindingRestElement TypeSuffix?

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  # NOTE: Merged in SingleNameBinding
  ( BindingIdentifier / BindingPattern ) TypeSuffix? Initializer? ParameterElementDelimiter ->
    return {
      type: "Parameter",
      children: $0,
      names: $1.names,
    }

ParameterElementDelimiter
  _* Comma
  &( __ ")" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  __ Identifier ->
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  __ ObjectBindingPattern:p ->
    p.children.unshift($1)
    return p
  __ ArrayBindingPattern:p ->
    p.children.unshift($1)
    return p

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  OpenBrace ObjectBindingPatternContent:c __ CloseBrace ->
    c.children.unshift($1)
    c.children.push($3, $4)
    return c

ObjectBindingPatternContent
  # NOTE: Added indentation based binding properties
  &EOS NestedBindingProperties -> $2
  BindingProperty*:props ( __ BindingRestProperty )?:rest ->
    const names = props.flatMap((p) => p.names)

    if (rest) {
      props.push(...rest)
      names.push(...rest[1].names)
    }

    return {
      type: "BindingPattern",
      names,
      children: props
    }

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  OpenBracket ArrayBindingPatternContent:c __ CloseBracket ->
    return {
      type: "BindingPattern",
      names: c.names,
      children: $0
    }

ArrayBindingPatternContent
  # NOTE: Added indentation based binding elements
  &EOS NestedBindingElements -> $2
  ( BindingElement / Elision )*:props ( __ BindingRestElement )?:rest ->
    const names = props.flatMap((p) => p.names || [])

    if (rest) {
      props.push(...rest)
      names.push(...rest[1].names)
    }

    return {
      type: "BindingPattern",
      names,
      children: props
    }

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition is handled from outside rather than using left recursion here
  __ Comma

NestedBindingProperties
  PushIndent NestedBindingProperty*:props NestedBindingRestProperty?:rest PopIndent ->
    if (!(props.length || rest)) return $skip
    const names = props.flatMap(p => p.names)
    if (rest) {
      props.push(rest)
      names.push(...rest.names)
    }
    return {
      type: "BindingPattern",
      children: props,
      names: names,
    }

NestedBindingProperty
  Nested BindingProperty ->
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  __ PropertyName __ Colon ( BindingIdentifier / BindingPattern ):b Initializer? ObjectPropertyDelimiter ->
    return {
      type: "BindingPattern",
      names: b.names,
      children: $0
    }
  BindingIdentifier:b Initializer? ObjectPropertyDelimiter ->
    return {
      type: "BindingPattern",
      names: b.names,
      children: $0
    }

NestedBindingRestProperty
  Nested BindingRestProperty ->
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  DotDotDot BindingIdentifier ->
    $2.children.unshift($1)
    return $2

NestedBindingElements
  PushIndent NestedBindingElement*:props ( Nested BindingRestElement )?:rest PopIndent ->
    if (!(props.length || rest)) return $skip
    const names = props.flatMap(p => p.names)
    if (rest) {
      props.push(...rest)
      names.push(...rest[1].names)
    }

    return {
      type: "BindingPattern",
      children: props,
      names: names,
    }

NestedBindingElement
  Nested BindingElement ->
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-BindingElement
BindingElement
  # NOTE: Merged in SingleNameBinding
  ( BindingIdentifier / BindingPattern ):binding Initializer? ArrayElementDelimiter ->
    return {
      type: "BindingPattern",
      names: binding.names,
      children: $0
    }

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  DotDotDot ( BindingIdentifier / BindingPattern ):binding ->
    binding.children.unshift($1)
    return binding

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  FunctionExpression

FunctionSignature
  # NOTE: Merged in async and generator with optionals
  ( Async __ )? Function Star? BindingIdentifier?:id __ Parameters:parameters ReturnTypeSuffix? ->
    // id is an empty array if not present so it can be filled later without having to adjust the children array
    // like in the const assignment function declaration transformation
    id = id || []
    $0[3] = id

    return {
      type: "FunctionSignature",
      id,
      parameters,
      returnType: $7,
      ts: false,
      block: null,
      children: $0,
    }

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # TODO: block isn't actually optional in FunctionExpression only in declarations/TS overloads
  FunctionSignature:signature BracedBlock?:block ->
    // TS Function overloads
    if (!block) {
      signature.ts = true
      return signature
    }

    const suffix = signature.returnType
    const isVoid = suffix?.children?.[1]?.[0]?.[1]?.token === "void"
    if (module.config.implicitReturns && !isVoid) {
      module.addImplicitReturns(block)
    }

    // Attach the block
    $1.block = block
    $1.children.push(block)
    $1.type = "FunctionExpression"
    return $1

  # Ruby/Crystal style block shorthand
  Ampersand !_ CallExpressionRest+ ->
    $1.token = "$ => $"
    return {
      type: "ArrowFunction",
      children: [$1, $3],
    }

  # Binary ops
  Ampersand ![&] ( __ BinaryOp __ UnaryExpression )+ ->
    // Remove assertion
    $0.splice(1, 1)

    $1.token = "$ => $"
    const exp = module.processBinaryOpExpression($0)

    return {
      type: "ArrowFunction",
      children: exp,
    }

  # Unary ops
  [!~+-]+ Ampersand ->
    return {
      type: "ArrowFunction",
      children: ["$ => ", $1, "$"],
    }

ThinArrowFunction
  Parameters:parameters ReturnTypeSuffix?:suffix _* Arrow:arrow BracedOrEmptyBlock:block ->
    const isVoid = suffix?.children?.[1]?.[0]?.[1]?.token === "void"
    if (module.config.implicitReturns && !isVoid) {
      block = module.addImplicitReturns(block)
    }

    const id = []

    return {
      type: "FunctionExpression",
      id,
      parameters,
      returnType: suffix,
      ts: false,
      block: block,
      children: [
        { $loc: arrow.$loc, token: "function" },
        id,
        parameters,
        suffix,
        block
      ],
    }

Arrow
  "->" ->
    return { $loc, token: $1}

# NOTE: This is the body of if/else/for etc.
Block
  __ OpenBrace EOS NestedBlockStatements:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockStatements:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  ThenClause
  TrailingComment* Statement

ThenClause
  Then TrailingComment* Statement -> [$2, $3]

BracedOrEmptyBlock
  BracedBlock
  EmptyBlock

EmptyBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: [],
    children: $0,
  }

# This is a block that must include braces (function body, try/catch/finally)
BracedBlock
  TrailingComment* OpenBrace BracedContent:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockStatements:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }

  # Immediate nested object literal
  InsertOpenBrace &EOS ObjectLiteral:s InsertCloseBrace ->
    // Remove &EOS assertion
    $0.splice(1, 1)

    return {
      type: "BlockStatement",
      expressions: [s],
      children: $0,
    }

  # One liner
  InsertOpenBrace !EOS __ Statement:s InsertSpace InsertCloseBrace ->
    // Remove !EOS assertion
    $0.splice(1, 1)

    return {
      type: "BlockStatement",
      expressions: [s],
      children: $0,
    }

BracedContent
  &EOS NestedBlockStatements -> $2
  TrailingComment* Statement

NestedBlockStatements
  PushIndent NestedBlockStatement*:statements PopIndent ->
    if (!statements.length) return $skip
    return statements

NestedBlockStatement
  Nested StatementListItem StatementDelimiter

# https://262.ecma-international.org/#prod-Literal
Literal
  LiteralContent ->
    return {
      type: "Literal",
      children: $0,
      raw: $1.token,
    }

LiteralContent
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  CoffeeBooleansEnabled CoffeeScriptBooleanLiteral -> $2
  ( "true" / "false" ) NonIdContinue ->
    return { $loc, token: $1 }

CoffeeScriptBooleanLiteral
  ( "yes" / "on" ) NonIdContinue ->
    return { $loc, token: "true" }
  ( "no" / "off" ) NonIdContinue ->
    return { $loc, token: "false" }

Comma
  _* Comma _*

# https://262.ecma-international.org/#prod-Identifier
Identifier
  !ReservedWord IdentifierName -> $2

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  OpenBracket ArrayLiteralContent:content __ CloseBracket ->
    if (content.type === "RangeExpression") {
      content.children.push(...$3)
      return content
    }

    let children
    if (Array.isArray(content)) {
      children = [$1, ...content, ...$3, $4]
    } else {
      children = [$1, content, ...$3, $4]
    }

    // Gather names when ArrayLiteral is used as a destructuring pattern
    const names = children.flatMap((c) => {
      return c.names || []
    })

    return {
      type: "ArrayExpression",
      children,
      names: names,
    }

ArrayLiteralContent
  ExtendedExpression:s __:ws ( DotDotDot / DotDot ):range ExtendedExpression:e ->
    const inclusive = range.token === ".."
    range.token = ","

    if (s.type === "Literal" && e.type === "Literal") {
      let start, end
      if (s.raw[0] === "'") {
        start = s.raw.match(/^'(.*)'$/)[1]
      } else {
        start = JSON.parse(s.raw)
      }
      if (e.raw[0] === "'") {
        end = e.raw.match(/^'(.*)'$/)[1]
      } else {
        end = JSON.parse(e.raw)
      }

      if (typeof start !== typeof end) {
        throw new Error("Range start and end must be of the same type")
      }

      if (typeof start === "string") {
        if (start.length !== 1 || end.length !== 1) {
          throw new Error("String range start and end must be a single character")
        }

        const startCode = start.charCodeAt(0)
        const endCode = end.charCodeAt(0)
        const step = startCode < endCode ? 1 : -1

        const length = Math.abs(endCode - startCode) + (inclusive ? 1 : 0)
        if (length <= 26) {
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => JSON.stringify(String.fromCharCode(startCode + i * step))).join(", "), "]"],
            inclusive,
            start: s,
            end: e
          }
        } else {
          const inclusiveAdjust = inclusive ? " + 1" : ""
          const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => String.fromCharCode(s + i * step))})(", startCode.toString(), ws, range, endCode.toString(), ")"]
          return {
            type: "RangeExpression",
            children,
            inclusive,
            start: s,
            end: e,
          }
        }
      } else if (typeof start === "number") {
        const step = end > start ? 1 : -1

        const length = Math.abs(end - start) + (inclusive ? 1 : 0)
        if (length <= 20) {
          // Use array of literal values
          return {
            type: "RangeExpression",
            children: ["[", Array.from({ length }, (_, i) => start + i * step).join(", "), "]"],
            inclusive,
            start: s,
            end: e,
          }
        }
      }
    }

    const inclusiveAdjust = inclusive ? " + 1" : ""
    const children = ["((s, e) => {let step = e > s ? 1 : -1; return Array.from({length: Math.abs(e - s)", inclusiveAdjust, "}, (_, i) => s + i * step)})(", s, ws, range, e, ")"]

    return {
      type: "RangeExpression",
      children,
      inclusive,
      start: s,
      end: e,
    }

  NestedElementList
  ElementList

NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements.flat()
    return $skip

NestedElement
  Nested ElementList ArrayElementDelimiter ->
    const result = [...$1, ...$2]
    if ($3) {
      result.push($3)
    }
    return result

ArrayElementDelimiter
  _* Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  ArrayElementExpression ElementListRest* ->
    if ($2.length) {
      return [].concat($1 || [], ...$2)
    }
    if ($1) {
      return [].concat($1)
    }
    return []

ElementListRest
  __ Comma __ ArrayElementExpression ->
    const result = [...$1, $2, ...$3]
    if ($4) {
      result.push($4)
    }
    return result

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  ( ( DotDotDot __ )? ExtendedExpression )? ->
    if ($1 && !$1[0]) {
      return $1[1]
    }
    return $1

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  BracedObjectLiteral
  NestedObjectLiteral
  InlineObjectLiteral

BracedObjectLiteral
  OpenBrace BracedObjectLiteralContent? __ CloseBrace ->
    if($2) {
      $2.unshift($1)
      if ($3.length) {
        $2.push(...$3)
      }
      $2.push($4)

      return {
        type: "ObjectExpression",
        children: $2,
        names: $2.flatMap((c) => {
          return c.names || []
        }),
      }
    }

    return {
      type: "ObjectExpression",
      children: [$1, ...$3, $4],
      names: [],
    }

BracedObjectLiteralContent
  &EOS NestedPropertyDefinitions -> $2
  __ PropertyDefinitionList ( __ Comma )? ->
    if ($1.length) {
      $2.splice(0, 0, ...$1)
    }
    if ($3) {
      $2.push($3)
    }
    return $2

NestedObjectLiteral
  InsertOpenBrace &EOS NestedPropertyDefinitions InsertNewline InsertIndent InsertCloseBrace ->
    $3.unshift($1)
    $3.push($4, $5, $6)

    return {
      type: "ObjectExpression",
      children: $3,
    }

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs.flat()

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested PropertyDefinition ObjectPropertyDelimiter ->
    const result = [...$1, $2]
    if ($3) {
      result.push($3)
    }
    return result

InlineObjectLiteral
  InsertOpenBrace SnugNamedProperty ( TrailingComment* Comma __ NamedProperty )* InsertCloseBrace ->
    // Drop leading space from inserted brace
    return [$1[1], $2, ...$3.flat(), $4]

ObjectPropertyDelimiter
  _* Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS ->
    return { $loc, token: "," }

PropertyDefinitionList
  PropertyDefinition ( ObjectPropertyDelimiter __ PropertyDefinition )* ->
    if ($2.length) {
      return [].concat($1 || [], ...$2)
    }
    if ($1) {
      return [].concat($1)
    }
    return []

# https://262.ecma-international.org/#prod-PropertyDefinition
PropertyDefinition
  # NOTE: Added CoffeeScript {@id} -> {id: this.id} shorthand
  At:at IdentifierReference:id &ObjectPropertyDelimiter ->
    at.token = "this."
    return {
      type: "Property",
      children: [id, ": ", at, id],
      names: id.names,
    }
  NamedProperty
  MethodDefinition
  DotDotDot ExtendedExpression
  # NOTE: this needs to be at the bottom to prevent shadowing PropertyName
  IdentifierReference

NamedProperty
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  PropertyName __ Colon ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      names: exp.names || [],
    }

# Named property but doesn't allow any space between name and colon
# used to distinguish between braceless inline objects and ternary expression conditions
SnugNamedProperty
  PropertyName Colon ExtendedExpression:exp ->
    return {
      type: "Property",
      children: $0,
      names: exp.names || [],
    }

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  StringLiteral
  IdentifierName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  OpenBracket ExtendedExpression __ CloseBracket

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  # NOTE: Not adding extra validation using PropertySetParameterList
  MethodSignature:sig BracedBlock:block ->
    const isConstructor = sig.name       === "constructor"
    const isVoid        = sig.returnType === "void"
    const isSet         = sig.modifier   === "set"

    if (module.config.implicitReturns && !isConstructor && !isSet && !isVoid) {
      block = module.addImplicitReturns(block)
    }

    return $0

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet TrailingComment*
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )?
  Star __
  Async __

# TypeScript method signature
MethodSignature
  ConstructorShorthand Parameters ->
    return {
      type: "MethodSignature",
      children: $0,
      name: $1.token,
      returnType: undefined,
    }

  MethodModifier? ClassElementName:name _* NonEmptyParameters ReturnTypeSuffix?:suffix ->
    // Normalize name so we can check if it is `constructor`
    if (name.name) {
      name = name.name
    } else if (name.token) {
      name = name.token.match(/^(?:"|')/) ? name.token.slice(1, -1) : name.token
    }

    return {
      type: "MethodSignature",
      children: $0,
      name: name,
      modifier: $1?.[0]?.token, // get/set
      // TODO: get return type from type annotation
      returnType: undefined,
    }

ClassElementName
  PropertyName
  PrivateIdentifier

PrivateIdentifier
  $("#" IdentifierName) ->
    return {
      type: "Identifier",
      name: $0,
      names: [$0],
      children: [{
        $loc: $loc,
        token: $0,
      }],
    }

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol ->
    return { $loc, token: $1 }

AssignmentOpSymbol
  "**="
  "*="
  "/="
  "%="
  "+="
  "-="
  "<<="
  ">>>="
  ">>="
  "&&="
  "&="
  "^="
  "||="
  "|="
  "??="
  "?=" -> "??="
  "="

BinaryOp
  BinaryOpSymbol ->
    if (typeof $1 === "string") return { $loc, token: $1 }
    return $1

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "/"
  "%"
  "+"
  "-"
  "<="
  ">="
  "<<"
  "<"
  ">>>"
  ">>"
  ">"
  "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" ->
    if(module.config.coffeeEq) return "!=="
    return $1
  "isnt" NonIdContinue ->
    if(module.config.coffeeIsnt) return "!=="
    return $skip
  "is" NonIdContinue -> "==="
  "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" ->
    if(module.config.coffeeEq) return "==="
    return $1
  "and" NonIdContinue -> "&&"
  "&&"
  CoffeeOfEnabled "of" NonIdContinue -> "in"
  "or" NonIdContinue -> "||"
  "||"
  "??"
  CoffeeBinaryExistentialEnabled "?" -> "??"
  "instanceof" NonIdContinue ->
    return $1
  CoffeeOfEnabled "in" NonIdContinue ->
    return {
      ref: module.getIndexOfRef(),
      suffix: " >= 0",
    }
  CoffeeOfEnabled "not" NonIdContinue __ "in" NonIdContinue ->
    return {
      ref: module.getIndexOfRef(),
      suffix: " < 0",
    }
  "in" NonIdContinue ->
    return $1
  "&"
  "^"
  "|"

UnaryOp
  # Lookahead to prevent unary operators from overriding block unary operator shorthand
  /[!~+-](?!\s|[!~+-]*&)/ ->
    return { $loc, token: $0 }
  ( Await / Delete / Void / Typeof ) __
  Not # only when CoffeeNotEnabled (see definition of `Not`)

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  ImportDeclaration
  ExportDeclaration
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  Declaration
  # NOTE: Added postfix conditionals/loops
  Statement:statement TrailingComment*:ws PostfixStatement?:post ->
    if (post) {
      let children, expressions
      if (post.blockPrefix?.length) {
        let indent = post.blockPrefix[0][0]
        expressions = [...post.blockPrefix, [indent, statement]]
        children = [" {\n", ...expressions, "\n", indent.slice(0, -2), "}"]
      } else {
        expressions = [["", statement]]
        children = [" { ", ...expressions, " }"]
      }

      const block = {
        type: "BlockStatement",
        children,
        expressions,
      }

      post.block = block
      post.children.push(block)

      // This removes trailing whitespace for easier testing
      if (!module.isWhitespaceOrEmpty(ws)) post.children.push(ws)
      return post
    }
    return statement

PostfixStatement
  ForClause
  IfClause
  LoopClause
  UnlessClause
  WhileClause

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  BlockStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement

  EmptyStatement
  ExpressionStatement

  # NOTE: no WithStatement
  # NOTE: no LabelledStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  TrailingComment* &";" -> { type: "EmptyStatement", children: $1 }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  __ OpenBrace EOS NestedBlockStatements:exps __ CloseBrace !( __ "=" ) -> {
    type: "BlockStatement",
    children: $0,
    expressions: exps,
  }

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Added paren-less condition
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  (IfClause / UnlessClause):clause Block:block ElseClause?:e ->
    clause.children.push(block)
    if (e) clause.children.push(e)
    return clause

ElseClause
  &EOS Samedent Else Block -> [$2, $3, $4]
  TrailingComment* Else Block

IfClause
  If Condition -> { type: "IfStatement", children: $0 }

UnlessClause
  Unless:kind Condition:condition ->
    // Rewrite unless to if
    condition.children.unshift("(!")
    condition.children.push(")")
    kind.token = "if"

    return {
      type: "IfStatement",
      children: [kind, condition],
    }

# NOTE: Added IfExpression from CoffeeScript
IfExpression
  IfClause:clause ExpressionBlock:b ( __ Else ExpressionBlock )?:e ->
    clause.children.shift() // Remove 'if'
    clause.children.push("?", b, ":") // Add ternary
    if (e) {
      e.splice(1, 1) // Remove 'else'
      clause.children.push(e)
    }
    else {
      clause.children.push("void 0")
    }
    clause.type = "IfExpression"
    return clause

# Block of expressions that can't include pure statements
ExpressionBlock
  # NOTE: Added indentation based implied braces
  InsertOpenParen EOS NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseParen ->
    exps[exps.length-1].pop()
    return {
      type: "BlockExpressions",
      expressions: exps,
      children: $0,
    }
  Then? ExtendedExpression

NestedBlockExpressions
  PushIndent NestedBlockExpression*:exps PopIndent ->
    if (!exps.length) return $skip
    return exps

NestedBlockExpression
  Nested ExtendedExpression ExpressionDelimiter

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  !CoffeeDoEnabled DoWhileStatement -> $2
  WhileStatement
  ForStatement

IterationExpression
  IterationStatement ->
    return module.expressionizeIteration($1)

# NOTE: Added from CoffeeScript
LoopStatement
  LoopClause:clause Block:block ->
    clause.block = block
    clause.children.push(block)
    return clause

LoopClause
  Loop -> {
    type: "IterationStatement",
    children: [ $1],
    block: null
  }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  Do BracedBlock:block __ WhileClause -> {
    type: "IterationStatement",
    children: $0,
    block: block
  }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause:clause Block:block ->
    clause.block = block
    clause.children.push(block)
    return clause

WhileClause
  ( While / Until ):kind TrailingComment*:ws Condition:cond ->
    if (kind.token === "until") {
      kind.token = "while"

      cond.children.unshift("(!")
      cond.children.push(")")
    }

    return {
      type: "IterationStatement",
      children: $0,
      block: null,
    }

# https://262.ecma-international.org/#prod-ForStatement
# https://262.ecma-international.org/#prod-ForInOfStatement
# NOTE: Merged into single rule
ForStatement
  ForClause:clause Block:block ->
    clause.children.push(block)
    clause.block = block
    if (clause.blockPrefix) {
      block.expressions.splice(0, 0, ...clause.blockPrefix)
    }
    return clause

ForClause
  For __ ForStatementControl:c  ->
    const {children, declaration} = c
    children.splice(0, 0, $1, ...$2)

    return {
      type: "ForStatement",
      children: children,
      declaration: declaration,
      block: null,
      blockPrefix: c.blockPrefix,
    }

ForStatementControl
  !CoffeeForLoopsEnabled ForStatementParameters -> $2
  CoffeeForLoopsEnabled CoffeeForStatementParameters WhenCondition? ->
    if ($3) {
      const indent = "".padStart((module.currentIndent + 1) * 2)
      module.insertTrimmingSpace($3, "")
      $2.blockPrefix.push({
        type: "IfStatement",
        children: [indent, "if (!(", $3, ")) continue\n"],
      })
    }

    return $2

WhenCondition
  __ When ExtendedExpression:exp -> exp

CoffeeForStatementParameters
  # NOTE: Coffee for loops can't have parens
  ( Await __ )? InsertOpenParen:open CoffeeForDeclaration:declaration __ ( In / Of / From ):kind ExtendedExpression:exp ( __ By ExtendedExpression )?:step InsertCloseParen:close ->
    let blockPrefix = []
    const indent = "".padStart((module.currentIndent + 1) * 2)

    if (kind.token === "from") {
      if (step) {
        throw new Error("Can't use 'by' with 'from' in CoffeeScript for loops")
      }
      kind.token = "of"
    } else if (kind.token === "of") {
      if (step) {
        throw new Error("Can't use 'by' with 'of' in CoffeeScript for loops")
      }

      module.insertTrimmingSpace(declaration, "")
      module.insertTrimmingSpace(exp, "")

      if (declaration.own) {
        const indent = "".padStart((module.currentIndent + 1) * 2)
        const hasPropRef = module.getHasPropRef()

        blockPrefix.push([indent, "if (!", hasPropRef, ".call(", exp, ", ", declaration, ")) continue\n"])
      }
      kind.token = "in "
    } else if (kind.token === "in") {
      // TODO: Coffee loop comprehensions
      const counterRef = {
        type: "Ref",
        base: "i",
      }

      const lenRef = {
        type: "Ref",
        base: "len",
      }

      // If exp isn't a simple identifier use a ref
      let expRef
      switch(exp.type) {
        case "Identifier":
          expRef = exp
          break
        case "RangeExpression": {
          const {start, end, inclusive} = exp

          const stepExp = step?.[2]
          let stepRef
          if (stepExp) {
            module.insertTrimmingSpace(stepExp, "")
            if (stepExp.type === "Literal") {
              stepRef = stepExp
            } else {
              stepRef = {
                type: "Ref",
                base: "step",
              }
            }
          }

          let startRef, endRef
          if (start.type === "Literal") {
            startRef = start
          } else if (start.type === "Identifier") {
            startRef = start
          } else {
            startRef = {
              type: "Ref",
              base: "ref",
            }
          }

          if (end.type === "Literal") {
            endRef = end
          } else if (end.type === "Identifier") {
            endRef = end
          } else {
            endRef = {
              type: "Ref",
              base: "ref",
            }
          }

          const startRefDec = (startRef !== start) ? [startRef, " = ", start, ", "] : []
          const endRefDec = (endRef !== end) ? [endRef, " = ", end, ", "] : []
          const varRef = declaration
          const ascDec = stepRef
          ? stepRef !== stepExp
            ? [", step = ", stepExp]
            : []
          : [", asc = ", startRef, " <= ", endRef]
          declaration = {
            type: "Declaration",
            children: ["let ", ...startRefDec, ...endRefDec, counterRef, " = ", varRef, " = ", startRef, ...ascDec],
            names: []
          }

          blockPrefix.push([{
            type: "AssignmentExpression",
            children: [], // Empty assignment to trigger auto-var
            names: varRef.names,
          }])

          const counterPart = inclusive
            ? [counterRef, " <= ", endRef, " : ", counterRef, " >= ", endRef]
            : [counterRef, " < " , endRef, " : ", counterRef, " > " , endRef]

          const condition = stepRef
            ? [stepRef, " !== 0 && (", stepRef, " > 0 ? ", ...counterPart, ")"]
            : ["asc ? ", ...counterPart]

          const increment = stepRef
          ? [varRef, " = ", counterRef, " += ", stepRef]
          : [varRef, " = asc ? ++", counterRef, " : --", counterRef]

          return {
            declaration,
            children: [$1, open, declaration, "; ", ...condition, "; ", ...increment, close],
            blockPrefix,
          }
        }
        default:
          expRef = {
            type: "Ref",
            base: "ref",
          }
      }

      if (step) {
        throw new Error("by clause not yet implement in non-range for in loops")
      }

      const varRef = declaration

      // Trim a single leading space if present
      module.insertTrimmingSpace(exp, "")

      const expRefDec = (expRef !== exp) ? [expRef, " = ", exp, ", "] : []

      declaration = {
        type: "Declaration",
        children: ["let ", ...expRefDec, counterRef, " = 0, ", lenRef, " = ", expRef, ".length"],
        names: []
      }

      blockPrefix.push([{
        type: "AssignmentExpression",
        children: [indent, varRef, " = ", expRef, "[", counterRef, "]\n"],
        names: varRef.names,
      }])

      return {
        declaration,
        children: [$1, open, declaration, "; ", counterRef, " < ", lenRef, "; ", counterRef, "++", close],
        blockPrefix,
      }
    }

    return {
      declaration,
      children: $0,
      blockPrefix,
    }

CoffeeForDeclaration
  # NOTE: Coffee doesn't allow expression bindings like `for a.x in b`
  ( __ "own" )?:own ForBinding:binding ->
    if (own) {
      binding.own = true
    }

    // Flag as assignment for auto-var
    binding.type = "AssignmentExpression"

    return binding

ForStatementParameters
  # https://262.ecma-international.org/#prod-ForStatement
  OpenParen __       ( LexicalDeclaration / VariableStatement / Expression? ):declaration __ Semicolon Expression? Semicolon Expression? __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  InsertOpenParen __ ( LexicalDeclaration / VariableStatement / Expression? ):declaration __ Semicolon Expression? Semicolon (!EOS Expression)? InsertCloseParen ->
    return {
      declaration,
      children: $0,
    }

  # https://262.ecma-international.org/#prod-ForInOfStatement
  # NOTE: Consolidated declarations
  # NOTE: Consolidated optional 'await'
  ( Await __ )? OpenParen __    ForInOfDeclaration:declaration __ ( In / Of ) ExpressionWithIndentedApplicationSuppressed __ CloseParen ->
    return {
      declaration,
      children: $0,
    }
  # NOTE: Added optional parens
  ( Await __ )? InsertOpenParen ForInOfDeclaration:declaration __ ( In / Of ) ExpressionWithIndentedApplicationSuppressed InsertCloseParen ->
    return {
      declaration: declaration,
      children: $0,
    }

# NOTE: Consolidated declarations
ForInOfDeclaration
  Var ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: $0,
      names: binding.names,
    }
  ForDeclaration
  LeftHandSideExpression

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConst:c NonIdContinue ForBinding:binding ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      names: binding.names,
    }
  # NOTE: Added default implicit const to for bindings
  # NOTE: the assertion is a bit of a hack to prevent valid LHS expressions from only parsing the identifier and matching this rule
  # i.e. a.x would match as identifier `a` without this lookahead
  InsertConst:c ForBinding:binding /(?=[\s\)])/ ->
    return {
      type: "ForDeclaration",
      children: [c, binding],
      names: binding.names,
    }

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  BindingIdentifier
  BindingPattern

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch ( EmptyCondition / Condition ):condition CaseBlock:caseBlock ->
    if (condition.type === "EmptyCondition") {
      // Negate all case condition expressions. This converts them to booleans
      // and is slightly smaller than switch(true) {case: !!exp ... }
      caseBlock.clauses.forEach(({cases}) => {
        if (cases) {
          cases.forEach((c) => {
            const exp = c[1]
            switch(exp.type) {
              case "Identifier":
              case "Literal":
                c.splice(1, 0, "!")
                break;
              default:
               c.splice(1, 1, "!(", exp, ")")
            }
          })
        }
      })
    }

    return {
      type: "SwitchStatement",
      children: $0
    }

EmptyCondition
  &EOS ->
    return {
      type: "EmptyCondition",
      children: [{
        $loc,
        token: " (false)",
      }]
    }

# NOTE: Added from CoffeeScript
SwitchExpression
  SwitchStatement:e ->
    // Add returns to when blocks
    module.addImplicitReturns(e.children[2])
    e.type = "SwitchExpression"
    // wrap with IIFE
    e.children = ["(()=>{", e.children, "})()"]
    return e

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  __ OpenBrace &EOS NestedCaseClauses:clauses __ CloseBrace ->
    $0.splice(2, 1)

    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  &EOS InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    $0.shift()

    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested CaseClause ->
    // Bring the indent into the clause
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  # NOTE: This differs from ESTree significantly to be easier to work with for implicit returns
  Case CaseExpressionList:cases ( NestedBlockStatements / NoExpressions ):expressions -> {
    type: "CaseClause",
    cases,
    expressions,
    children: $0
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList:cases ( ThenClause / NestedBlockStatements ):expressions InsertBreak -> {
    type: "WhenClause",
    cases,
    expressions,
    children: $0
  }
  # NOTE: Merged in default clause
  Default ImpliedColon ( NestedBlockStatements / NoExpressions ):exps -> {
    type: "DefaultClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Added else from CoffeesScript
  Else ImpliedColon ( NestedBlockStatements / ( TrailingComment* Statement ) ):exps ->
    $1.token = "default"
    return {
      type: "DefaultClause",
      expressions: exps,
      children: $0
    }

CaseExpressionList
  ( _* ExpressionWithIndentedApplicationSuppressed ImpliedColon ) ( __ Comma ExpressionWithIndentedApplicationSuppressed ImpliedColon )* ->
    // Convert comma separated expression list to `case <exp>:`
    const result = $2.map(([ws, _comma, exp, col]) => {
      module.insertTrimmingSpace(exp, "")

      if (ws.length) return [module.insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result.unshift($1)

    return result

NoExpressions
  "" -> []

ImpliedColon
  __ Colon
  "" ->
    return { $loc, token: ":" }

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try:t BracedBlock:b CatchClause?:c Finally?:f ->
    if (!c && !f) {
      return {
        type: "TryStatement",
        children: [t, b, " catch(e) {}"]
      }
    }

    return {
      type: "TryStatement",
      children: [t, b, c, f]
    }

# https://262.ecma-international.org/#prod-Catch
CatchClause
  __ Catch CatchBind? BracedBlock

# NOTE: Added optional parentheses to catch binding
CatchBind
  __ OpenParen __ CatchParameter __ CloseParen
  !EOS TrailingComment* InsertOpenParen CatchParameter InsertCloseParen

# https://262.ecma-international.org/#prod-Finally
Finally
  __ "finally" BracedBlock

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier
  BindingPattern

# An expression with explicit or implied parentheses, for use in if/while/switch
Condition
  ParenthesizedExpression !( TrailingComment* ( BinaryOp / AssignmentOp ) ) -> $1
  InsertOpenParen ExpressionWithIndentedApplicationSuppressed:exp InsertCloseParen ->
    // Don't double wrap parethesized expressions
    if (exp.type === "ParenthesizedExpression") return exp
    module.insertTrimmingSpace(exp, "")
    return {
      type: "ParenthesizedExpression",
      children: $0
    }

ExpressionWithIndentedApplicationSuppressed
  SuppressIndentedApplication ExtendedExpression?:exp ->
    module.suppressIndentedApplication = false

    if (exp) return exp
    return $skip

SuppressIndentedApplication
  "" ->
    module.suppressIndentedApplication = true

# https://262.ecma-international.org/#prod-ExpressionStatement
ExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  Expression

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: no label
  "break" NonIdContinue -> {
    type: "BreakStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: no label
  "continue" NonIdContinue -> {
    type: "ContinueStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#sec-debugger-statement
  "debugger" NonIdContinue -> {
    type: "DebuggerStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ReturnStatement
  Return MaybeNestedExpression? -> {
    type: "ReturnStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ThrowStatement
  Throw ExtendedExpression -> {
    type: "ThrowStatement",
    children: $0,
  }

DebuggerExpression
  "debugger" NonIdContinue ->
    return {
      type: "DebuggerExpression",
      children: ["(()=>{", $1, "})()"],
    }

ThrowExpression
  Throw ExtendedExpression ->
    return {
      type: "ThrowExpression",
      children: ["(()=>{", $0, "})()"],
    }

MaybeNestedExpression
  !EOS TrailingComment* AssignmentExpression ->
    return [...$2, $3]
  &EOS ObjectLiteral -> $2

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  "import type" NonIdContinue __ ImportClause __ FromClause -> { ts: true, children: $0 }
  Import __ ImportClause __ FromClause
  Import __ ModuleSpecifier
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ImportClause:c __:w FromClause:f ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: f[0].$loc.pos-1,
      length: f[0].$loc.length+1,
    }
    return [i, c, w, f]

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding:binding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?:rest ->
    if (rest) {
      return {
        type: "Declaration",
        children: $0,
        names: [...binding.names, ...rest[3].names],
      }
    }

    $1.type = "Declaration"
    return $1
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star __ As __ ImportedBinding:binding  ->
    return {
      type: "Declaration",
      children: $0,
      names: binding.names
    }

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace ImportSpecifier*:specifiers ( __ Comma )? __ CloseBrace ->
    const names = specifiers.flatMap(({binding}) => {
      return binding.names
    })

    return {
      type: "Declaration",
      children: $0,
      names
    }

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName __ As __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding: binding,
      children: $0,
    }
  __ ImportedBinding:binding ObjectPropertyDelimiter ->
    return {
      binding: binding,
      children: $0,
    }

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ->
    // Workaround to fix:
    // https://github.com/microsoft/TypeScript/issues/42151
    // import t.ts
    // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
    const {token} = $1
    // convert .[mc]?ts to .[mc]?js
    return { $loc, token: token.replace(/\.([mc])?ts(['"])$/, ".$1js$2") }

UnprocessedModuleSpecifier
  BasicStringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing all characters except for whitespace, double quotes, and semi-colon
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  # NOTE: Using ExtendedExportDeclaration to allow If/Switch expressions
  Export __ "default" NonIdContinue __ ( HoistableDeclaration / ClassDeclaration / ExtendedExpression )
  Export __ ExportFromClause __ FromClause
  Export __ ( NamedExports / VariableStatement / Declaration )

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As __ ModuleExportName )?
  NamedExports

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-Declaration
Declaration
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration
  TypeDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst LexicalBinding:binding ( __ Comma LexicalBinding )*:tail ->
    return {
      type: "Declaration",
      children: $0,
      names: [...binding.names].concat(tail.flatMap(([,,b]) => b.names)),
    }
  # NOTE: Added const shorthand
  # NOTE: Using ExtendedExpression to allow for If/SwitchExpressions
  InsertConst:c ( BindingPattern / BindingIdentifier ):id TypeSuffix? __ ConstAssignment:ca ExtendedExpression:e ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    c.$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }

    let exp
    if (e.type === "FunctionExpression") {
      exp = e
    } else {
      exp = e[1]
    }

    // TODO: Better AST nodes so we don't have to adjust for whitespace nodes here
    if (exp?.children?.[0]?.token?.match(/^\s+$/)) exp.children.shift()

    if (id.type === "Identifier" && exp?.type === "FunctionExpression") {
      if (exp.id.length === 0) {
        exp.id.push(" ", id, $3, $4)
      }
      exp.type = "Declaration"
      exp.names = id.names
      return exp
    }

    return {
      type: "Declaration",
      names: id.names,
      children: $0
    }

ConstAssignment
  ":=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
LexicalBinding
  BindingPattern TypeSuffix? Initializer ->
    if ($2) $1.children.push($2)
    $1.children.push($3)
    return $1
  BindingIdentifier TypeSuffix? Initializer? ->
    if ($2) $1.children.push($2)
    if ($3) $1.children.push($3)
    return $1

# https://262.ecma-international.org/#prod-Initializer
Initializer
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ Equals ExtendedExpression

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList ->
    $3.children.splice(0, 0, $1, ...$2)
    return $3

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  VariableDeclaration ( __ Comma __ VariableDeclaration )* ->
    let children
    if ($2.length) {
      children = [$1, ...$2]
    }else {
      children = [$1]
    }

    const names = children.flatMap((c) => c.names || [])

    return {
      type: "Declaration",
      children,
      names,
    }

# https://262.ecma-international.org/#prod-VariableDeclaration
VariableDeclaration
  BindingPattern TypeSuffix? Initializer ->
    if ($2) $1.children.push($2)
    $1.children.push($3)
    return $1

  BindingIdentifier TypeSuffix? Initializer? ->
    if ($2) $1.children.push($2)
    if ($3) $1.children.push($3)
    return $1

# https://262.ecma-international.org/#prod-NumericLiteral
NumericLiteral
  NumericLiteralKind ->
    return { $loc, token: $1 }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

# https://262.ecma-international.org/#prod-DecimalLiteral
DecimalLiteral
  # NOTE: Not matching the dot as part of a number if it is followed by a valid JS identifier so that it will match as a property access
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?=\.(?:\p{ID_Start}|[_$]))/ ) ->
    // Insert an extra dot to make property access work
    return $1 + "."
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?:\.(?:[0-9](?:_[0-9]|[0-9])*))?/ ExponentPart? )
  $( /(?:\.[0-9](?:_[0-9]|[0-9])*)/ ExponentPart? )

ExponentPart
  /(?:[eE][+-]?[0-9]+(?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*n?/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*n?/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*n?/

# https://262.ecma-international.org/#prod-StringLiteral
StringLiteral
  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplifed
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return module.dedentBlockSubstitutions($0)

  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return [s, module.dedentBlockString(str), e]

  # CoffeeScript Interpolation is enabled when "civet coffee-compat" or "civet coffee-interpolation" directive is present
  CoffeeInterpolatedDoubleQuotedString
  BasicStringLiteral

BasicStringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      token: `"${module.modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      token: `'${module.modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart ExtendedExpression __ CloseBrace

CoffeeInterpolatedDoubleQuotedString
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    const noInterpolations = parts.length === 1 && parts[0].token != null
    if (noInterpolations) {
      return {
        token: `"${module.modifyString(parts[0].token)}"`,
        $loc,
      }
    }

    parts.forEach((part) => {
      // Is a string
      if(part.token) {
        // Escape '${' and '`'
        const str = part.token.replace(/(`|\$\{)/g, "\\$1")
        // Escape non-continuation newlines
        part.token = module.modifyString(str)
      }
    })

    // Convert to backtick enclosed string
    s.token = e.token = "`"

    return [s, parts, e]

CoffeeDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpCharacter*

RegExpCharacter
  /(?:\\.|[^\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return module.dedentBlockSubstitutions($0)

  Backtick ( TemplateCharacters / TemplateSubstitution )* Backtick

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart ExtendedExpression __ CloseBrace

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  CoffeeBooleansEnabled /(?:on|off|yes|no)(?!\p{ID_Continue})/
  CoffeeIsntEnabled /(?:isnt)(?!\p{ID_Continue})/
  CoffeeForLoopsEnabled /(?:by)(?!\p{ID_Continue})/
  /(?:and|as|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|loop|new|null|or|return|static|super|switch|this|throw|true|try|typeof|unless|until|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  MultiLineComment
  SingleLineComment

SingleLineComment
  /\/\/[^\r\n]*/ ->
    return { $loc, token: $0 }
  CoffeeCommentEnabled CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#(?!##)([^\r\n]*)/ ->
    return { $loc, token: `//${$1}` }

CoffeeMultiLineComment
  "###" $( !("###" / "*/") . )* "###" ->
    return { $loc, token: `/*${$2}*/` }

# InlineComment is a multi-line comment with no line separators
InlineComment
  $( "/*" $(!"*/" [^\r\n] )* "*/" ) ->
    return { $loc, token: $1 }

RestOfLine
  (NonNewlineWhitespace / SingleLineComment / MultiLineComment)* EOL

TrailingComment
  (NonNewlineWhitespace / InlineComment / SingleLineComment)

# Non-newline "white space" (includes comments)
# TODO: JS counts line terminators that appear in multi-line comments. For example "return /*\n*/5" is different than "return /**/ 5" because of the newline within the comment
# NOTE: Maybe Comment should only be single line comments here?
_
  (NonNewlineWhitespace / Comment)+

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }
  CoffeeLineContinuationEnabled "\\" EOL -> ""

# Optional whitespace including newlines and comments
__
  (Whitespace / Comment)*

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

# Fake a blocklike form for single expressions
ExpressionDelimiter
  TrailingComment* Semicolon TrailingComment* ->
    $2.token = ","
    return $0
  &EOS ->
    return { $loc, token: "," }

StatementDelimiter
  TrailingComment* Semicolon TrailingComment*
  &EOS

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

Ampersand
  "&" ->
    return { $loc, token: $1 }

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

At
  "@" ->
    return { $loc, token: $1 }

Async
  "async" ->
    return { $loc, token: $1 }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1 }

Backtick
  "`" ->
    return { $loc, token: $1 }

By
  "by" NonIdContinue ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" ->
    return { $loc, token: $1 }

Class
  "class" ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Delete
  "delete" NonIdContinue ->
    return { $loc, token: $1 }

Do
  "do" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }

DotDot
  ".." ->
    return { $loc, token: $1 }

DotDotDot
  "..." ->
    return { $loc, token: $1 }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Else
  "else" ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1 }

If
  # NOTE: Pull a single space into the 'if ' token so if it is replaced
  # with a ternary in expressions it doesn't add an extra space
  $("if" " "?) ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  "let" / "const" ->
    return { $loc, token: $1 }

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while(true)" }

New
  "new" ->
    return { $loc, token: $1 }

Not
  # Not keyword only active in compat mode
  CoffeeNotEnabled "not" NonIdContinue " "? ->
    return { $loc, token: "!" }

Of
  "of" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand
  "@" !"(" ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" ->
    return { $loc, token: $1 }

Then
  # TODO: comments/whitespace get lost here
  __ "then" NonIdContinue ->
    return { $loc, token: "" }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" ->
    return { $loc, token: $1 }

Typeof
  "typeof" NonIdContinue ->
    return { $loc, token: $1 }

Unless
  "unless" ->
    return { $loc, token: $1 }

Until
  "until" NonIdContinue ->
    return { $loc, token: $1 }

Var
  "var" ->
    return { $loc, token: $1 }

Void
  "void" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

While
  "while" NonIdContinue ->
    return { $loc, token: $1 }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1 }

## JSX

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  JSXOpeningElement JSXChildren* __ JSXClosingElement ->
    // Check that tags match
    if ($1[1] !== $4[2]) {
      throw new Error(`mismatched closing tags at ${JSON.stringify($loc)}`)
    }
    return $0

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" $JSXElementName JSXAttributes? __ "/>"

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" $JSXElementName JSXAttributes? __ ">"

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" __ $JSXElementName __ ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  "<>" JSXChildren? "</>"

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( __ JSXAttribute )*

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  OpenBrace __ DotDotDot ExtendedExpression __ CloseBrace

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName JSXAttributeInitializer?

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  __ Equals __ JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  /"[^"]*"/
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  /'[^']*'/
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  OpenBrace ExtendedExpression __ CloseBrace
  JSXElement
  JSXFragment

# https://facebook.github.io/jsx/#prod-JSXChildren
JSXChildren
  ( __ JSXChild )*

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXText
  JSXElement
  JSXFragment
  OpenBrace JSXChildExpression? __ CloseBrace

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  [^{}<>]+

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  # NOTE: Using ExtendedExpression to allow If/Switch expressions
  __ ( DotDotDot __ )? ExtendedExpression

## Type Stuff

TypeDeclaration
  (TypeDeclarationModifier TrailingComment*)* TypeDeclarationRest -> { ts: true, children: $0 }

TypeDeclarationModifier
  "declare" NonIdContinue
  Export

TypeDeclarationRest
  TypeKeyword TrailingComment* IdentifierName TypeParameters? __ Equals __ Type
  Interface   TrailingComment* IdentifierName TypeParameters? InterfaceBlock
  Namespace   TrailingComment* IdentifierName NamespaceBlock
  FunctionSignature

TypeKeyword
  "type" NonIdContinue

Interface
  "interface" NonIdContinue

Namespace
  "namespace" NonIdContinue

InterfaceBlock
  __ OpenBrace EOS NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  ( TypeIndexSignature / PropertyName ) TypeSuffix InterfacePropertyDelimiter
  NonEmptyParameters TypeSuffix InterfacePropertyDelimiter
  MethodSignature InterfacePropertyDelimiter

InterfacePropertyDelimiter
  _* ( Semicolon / Comma )
  &( __ CloseBrace )
  &EOS

NamespaceBlock
  __ OpenBrace EOS NestedTypeDeclarations __ CloseBrace
  __ OpenBrace ( __ TypeDeclaration InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedTypeDeclarations InsertNewline InsertIndent InsertCloseBrace

NestedTypeDeclarations
  PushIndent NestedTypeDeclaration*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedTypeDeclaration
  Nested TypeDeclaration InterfacePropertyDelimiter

TypeIndexSignature
  ( [+-]? "readonly" __ )? OpenBracket TypeIndex CloseBracket ( __ [+-] QuestionMark )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

TypeSuffix
  QuestionMark? __ Colon Type -> {
    type: "TypeSuffix",
    ts: true,
    children: $0
  }

ReturnTypeSuffix
  __ Colon ( __ "asserts" NonIdContinue )? TypePredicate ->
    if (!$3) $0.splice(2, 1)
    if ($1.length === 0) $0.shift()

    return {
      type: "ReturnTypeAnnotation",
      children: $0,
      ts: true,
    }

TypePredicate
  Type ( __ "is" NonIdContinue Type )? ->
    if (!$2) return $1
    return $0

Type
  TypeConditional

TypeBinary
  TypeUnary (__ TypeBinaryOp __ TypeUnary)* ->
    if ($2.length) return $0
    return $1

TypeUnary
  ( __ TypeUnaryOp NonIdContinue )* TypePrimary TypeUnarySuffix* ->
    if (!$3.length) $0.pop()
    if (!$1.length) $0.shift()
    return $0

TypeUnarySuffix
  TypeIndexedAccess
  QuestionMark

TypeUnaryOp
  "keyof"
  "typeof"
  "infer"

TypeIndexedAccess
  __ OpenBracket Type? __ CloseBracket

TypePrimary
  InterfaceBlock
  __ OpenParen Type __ CloseParen
  __ TypeTuple
  _* FunctionType
  _* TypeLiteral
  _* IdentifierName (Dot IdentifierName)* TypeArguments?

TypeTuple
  OpenBracket NestedTypeList __ CloseBracket
  OpenBracket TypeList? __ CloseBracket

TypeList
  Type (__ Comma Type)*

NestedTypeList
  PushIndent NestedType*:types PopIndent ->
    if (types.length)
      return types
    return $skip

NestedType
  Nested Type ArrayElementDelimiter

TypeConditional
  TypeBinary ( __ "extends" Type ( __ QuestionMark Type __ Colon Type )? )? ->
    if ($2) return $0
    return $1

TypeLiteral
  Literal
  "void" ->
    return { $loc, token: "void" }
  "[]" ->
    return { $loc, token: "[]" }

TypeBinaryOp
  "|" ->
    return { $loc, token: "|" }
  "&" ->
    return { $loc, token: "&" }

FunctionType
  Parameters __ "=>" Type

TypeArguments
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">"

TypeParameters
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">" ->
    return { ts: true, children: $0 }

TypeParameter
  __ Identifier TypeConstraint? TypeParameterDelimiter

TypeConstraint
  __ "extends" Type

TypeParameterDelimiter
  _* Comma
   # NOTE: Don't insert comma before inline closing angle bracket
  &( _* ">" )
  # NOTE: Do insert comma before closing angle bracket on following line
  &( __ ">" ) ->
    return { $loc, token: "," }
  &EOS ->
    return { $loc, token: "," }

## Utility

Shebang
  /#![^\r\n]*/ EOL

CivetPrologue
  [\t ]* DoubleQuote CivetPrologueContent:content DoubleQuote $StatementDelimiter EOS -> content
  [\t ]* SingleQuote CivetPrologueContent:content SingleQuote $StatementDelimiter EOS -> content

CivetPrologueContent
  "civet" CivetOption*:options [\s]* ->
    return {
      type: "CivetPrologue",
      children: [],
      config: Object.fromEntries(options),
    }

CivetOption
  /\s+([+-]?)([a-zA-Z0-9-]+)/ ->
    // Normalize option names to camelCase
    const optionName = $2.replace(/-+([a-z]?)/g, (_, l) => {
      if (l) return l.toUpperCase()
      return ""
    })
    // - is disabled, + is enabled, no prefix is enabled
    const value = ($1 === "-") ? false : true

    return [optionName, value]

UnknownPrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  [\t ]* BasicStringLiteral:s $StatementDelimiter EOS

DirectivePrologue
  CivetPrologue
  UnknownPrologue

EOS
  RestOfLine+

# End of line, including EOF
EOL
  /\r\n|\n|\r|$/ ->
    return { $loc, token: $0 }

Debugger
  "" ->
    debugger

# Insertions

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return "".padStart(module.currentIndent * 2)

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: ";break;" }

CoffeeBinaryExistentialEnabled
  "" ->
    if(module.config.coffeeBinaryExistential) return
    return $skip

CoffeeBooleansEnabled
  "" ->
    if(module.config.coffeeBooleans) return
    return $skip

CoffeeClassesEnabled
  "" ->
    if(module.config.coffeeClasses) return
    return $skip

CoffeeCommentEnabled
  "" ->
    if(module.config.coffeeComment) return
    return $skip

CoffeeDoEnabled
  "" ->
    if(module.config.coffeeDo) return
    return $skip

CoffeeForLoopsEnabled
  "" ->
    if(module.config.coffeeForLoops) return
    return $skip

CoffeeInterpolationEnabled
  "" ->
    if(module.config.coffeeInterpolation) return
    return $skip

CoffeeIsntEnabled
  "" ->
    if(module.config.coffeeIsnt) return
    return $skip

CoffeeLineContinuationEnabled
  "" ->
    if(module.config.coffeeLineContinuation) return
    return $skip

CoffeeNotEnabled
  "" ->
    if(module.config.coffeeNot) return
    return $skip

CoffeeOfEnabled
  "" ->
    if(module.config.coffeeOf) return
    return $skip

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    module.currentIndent = 0
    module.indentLevels = [0]
    module.verbose = false
    module.config = {
      autoVar: false,
      coffeeBinaryExistential: false,
      coffeeBooleans: false,
      coffeeClasses: false,
      coffeeComment: false,
      coffeeDo: false,
      coffeeEq: false,
      coffeeForLoops: false,
      coffeeInterpolation: false,
      coffeeIsnt: false,
      coffeeLineContinuation: false,
      coffeeNot: false,
      coffeeOf: false,
      implicitReturns: true,
    }

    let indexOfRef, hasPropRef
    module.prelude = []

    module.getIndexOfRef = function() {
      if (indexOfRef) return indexOfRef

      indexOfRef = {
        type: "Ref",
        base: "indexOf",
      }

      const typeSuffix = {
        ts: true,
        children: [": <T>(this: T[], searchElement: T) => boolean"]
      }
      const asAny = {
        ts: true,
        children: [" as any"]
      }
      module.prelude.push(["", "const ", indexOfRef, typeSuffix, " = [].indexOf", asAny, "\n"])

      return indexOfRef
    }

    module.getHasPropRef = function() {
      if (hasPropRef) return hasPropRef

      hasPropRef = {
        type: "Ref",
        base: "hasProp",
      }

      const typeSuffix = {
        ts: true,
        children: [": <T>(this: T, prop: keyof T) => boolean"]
      }
      const asAny = {
        ts: true,
        children: [" as any"]
      }
      module.prelude.push(["", "const ", hasPropRef, typeSuffix, " = {}.hasOwnProperty", asAny, "\n"])

      return hasPropRef
    }

    // Expand setting coffeeCompat to the individual options
    Object.defineProperty(module.config, "coffeeCompat", {
      set(b) {
        if (b) {
          this.autoVar = true
          this.coffeeBinaryExistential = true
          this.coffeeBooleans = true
          this.coffeeClasses = true
          this.coffeeComment = true
          this.coffeeDo = true
          this.coffeeEq = true
          this.coffeeForLoops = true
          this.coffeeInterpolation = true
          this.coffeeIsnt = true
          this.coffeeLineContinuation = true
          this.coffeeNot = true
          this.coffeeOf = true
        } else {
          this.autoVar = false
          this.coffeeBinaryExistential = false
          this.coffeeBooleans = false
          this.coffeeClasses = false
          this.coffeeComment = false
          this.coffeeDo = false
          this.coffeeEq = false
          this.coffeeForLoops = false
          this.coffeeInterpolation = false
          this.coffeeIsnt = false
          this.coffeeLineContinuation = false
          this.coffeeNot = false
          this.coffeeOf = false
        }
      }
    })

    // TODO: this is only here because directive prologues depend on it
    // eventually all these `module.*` variables should be handled better in Hera
    // Adjust a parsed string by escaping newlines
    module.modifyString = function(str) {
      // Replace non-escaped newlines with escaped newlines
      // taking into account the possibility of a preceding escaped backslash
      return str.replace(/(?<!\\)(\\\\)*\n/g, '$1\\n')
    }

Init
  Shebang? DirectivePrologue*:directives "" ->
    directives.forEach((directive) => {
      if (directive.type === "CivetPrologue") {
        Object.assign(module.config, directive.config)
      }
    })

    module.expressionizeIteration = function(statement) {
      const resultsRef = {
        type: "Ref",
        base: "results",
      }

      // insert `results.push` to gather results array
      insertPush(statement.block, resultsRef)

      return {
        type: "IterationExpression",
        children: ["((", resultsRef, ")=>{", statement, "; return ", resultsRef, "})([])"],
      }
    }

    function wrapIterationReturningResults(statement, outerRef) {
      const resultsRef = {
        type: "Ref",
        base: "results",
      }

      const declaration = {
        type: "Declaration",
        children: ["const ", resultsRef, "=[];"],
      }

      insertPush(statement.block, resultsRef)

      statement.children.unshift(declaration)
      if (outerRef) {
        statement.children.push(";", outerRef, ".push(", resultsRef, ");")
      } else {
        statement.children.push(";return ", resultsRef, ";")
      }
    }

    // NOTE: this is almost the same as insertReturn but doesn't remove `breaks` in `when` and
    // does construct an else clause pushing undefined in if statements that lack them
    // and adds to the beginning and the end of the expression's children.
    // Maybe these insertion modifications can be refactored to be more DRY eventually.
    function insertPush(node, ref) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "AssignmentExpression":
          node.children.unshift(ref, ".push(")
          node.children.push(")")
          return
        case "Identifier":
          node.children.unshift(ref, ".push(")
          node.children.push(")")
          return
        case "BlockStatement":
          insertPush(node.expressions[node.expressions.length - 1], ref)
          return
        case "ObjectExpression":
          module.insertTrimmingSpace(node.children[0], "")
          node.children.unshift(ref, ".push(")
          node.children.push(")")
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertPush(clause, ref)
          })
          return
        case "CaseClause":
          // Don't adjust case clauses
          return
        case "WhenClause":
          insertPush(node.expressions[node.expressions.length - 1], ref)
          return
        case "DefaultClause":
          insertPush(node.expressions[node.expressions.length - 1], ref)
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node
      if (!exp) return

      let indent = node[0]
      // Hacky way to get the indent of the last expression
      if (Array.isArray(indent)) indent = indent[indent.length - 1]

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "Declaration":
          return
        case "ForStatement":
        case "IterationStatement":
          wrapIterationReturningResults(exp, ref)
          return
        case "BlockStatement":
          insertPush(exp.expressions[exp.expressions.length - 1], ref)
          return
        case "IfStatement":
          // if block
          insertPush(exp.children[2], ref)
          // else block
          if (exp.children[3]) insertPush(exp.children[3][2], ref)
          // Add else block pushing undefined if no else block
          else exp.children.push([" else {\n", indent, ref, ".push(undefined)\n", indent, "}"])
          return
        case "SwitchStatement":
          // insert a results.push in each case block
          insertPush(exp.children[2], ref)
          return
        case "TryStatement":
          // try block
          insertPush(exp.children[1], ref)
          // catch block
          insertPush(exp.children[2][3], ref)
          // NOTE: CoffeeScript doesn't add a push to an empty catch block but does add if there is any statement in the catch block
          // NOTE: do not insert a push in the finally block
          return
      }

      // Insert push wrapping expression
      node.splice(1, 0, ref, ".push(")
      node.push(")")
    }

    // [indent, statement, semicolon]
    function insertReturn(node) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "AssignmentExpression":
          node.children.unshift("return ")
          return
        case "Identifier":
          // TODO: It may be better to wrap/insert a node
          node.children.unshift("return ")
          return
        case "BlockStatement":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "ObjectExpression":
          module.insertTrimmingSpace(node.children[0], "")
          node.children.unshift("return ")
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertReturn(clause)
          })
          return
        case "CaseClause":
          // Don't adjust case clauses
          return
        case "WhenClause":
          // Remove inserted `break;`
          node.children.pop()
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "DefaultClause":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node
      let indent = node[0]
      // Hacky way to get the indent of the last expression
      if (Array.isArray(indent)) indent = indent[indent.length - 1]
      if (!exp) return

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "Declaration":
          return
        case "ForStatement":
        case "IterationStatement":
          wrapIterationReturningResults(exp)
          return
        case "BlockStatement":
          insertReturn(exp.expressions[exp.expressions.length - 1])
          return
        case "IfStatement":
          // if block
          insertReturn(exp.children[2])
          // else block
          if (exp.children[3]) insertReturn(exp.children[3][2])
          // Add explicit return after if block if no else block
          else exp.children.push(["\n", indent, "return"])
          return
        case "SwitchStatement":
          // insert a return in each case block
          insertReturn(exp.children[2])
          return
        case "TryStatement":
          // try block
          insertReturn(exp.children[1])
          // catch block
          insertReturn(exp.children[2][3])
          // NOTE: do not insert a return in the finally block
          return
      }

      // Insert return before expression
      node.splice(1, 0, "return ")
    }

    module.addImplicitReturns = function(block) {
      insertReturn(block)

      return block
    }

    module.isWhitespaceOrEmpty = function(node) {
      if (!node) return true
      if (!node.length) return true
      if (typeof node === "string") return node.match(/^\s*$/)
      if (Array.isArray(node)) return node.every(module.isWhitespaceOrEmpty)
    }

    module.processBinaryOpExpression = function($0) {
      const expandedOps = module.expandChainedComparisons($0)

      // Expanded ops is [a, __, op1, __, b, __, op2, __, c, __, op3, __, d], etc.
      // NOTE: all operators of higher precedence than relational have been merged into the operand expressions
      let i = 2
      while (i < expandedOps.length) {
        const op = expandedOps[i]
        // a in b -> indexOf.call(b, a) >= 0
        // a not in b -> indexOf.call(b, a) < 0
        // Currently indexOf is our only Ref type binary operator
        if (op.ref) {
          const [a, wsOp, op, wsB, b] = expandedOps.slice(i - 2, i + 3)

          module.insertTrimmingSpace(wsOp, "")
          module.insertTrimmingSpace(wsB, "")
          expandedOps.splice(i - 2, 5, {
            type: "Call",
            children: [wsOp, op.ref, ".call(", wsB, b, ", ", a, ")", op.suffix]
          })
        } else {
          i += 4
        }
      }

      return expandedOps
    }

    /**
    * binops is an array of [__, op, __, exp] tuples
    * first is an expression
    */
    module.expandChainedComparisons = function([first, binops]) {
      // TODO: add refs to ensure middle expressions are evaluated only once

      // all relational operators could be chained in theory, including in and instanceof
      const relationalOps = ["==", "===", "!=", "!==", "<", "<=", ">", ">=", "in", "instanceof"]

      // short circuit/bitwise ops have lower precedence than comparison ops
      // so we only need to look for chains in the sections between them
      const lowerPrecedenceOps = ["??", "&&", "||", "&", "|", "^"]

      // shift/arithmetic ops have higher precedence, they will bind to expressions inside the chains
      // const higherPrecedenceOps = ["<<", ">>", ">>>", "+", "-", "*", "**", "/", "%"]

      let results = []

      let i = 0
      let l = binops.length

      let start = 0
      // indexes of chainable ops
      let chains = []
      while (i < l) {
        const [, op] = binops[i]

        // NOTE: coffee `in` and `not in` are ops that use a ref to indexOf. They are our only ref ops so far and they are both relational.
        if (relationalOps.includes(op.token) || op.ref) {
          chains.push(i)
        } else if (lowerPrecedenceOps.includes(op.token)) {
          // end of the chain
          processChains()
          first = []
        }

        i++
      }

      processChains()

      return results

      function processChains() {
        if (chains.length > 1) {
          chains.forEach((index, k) => {
            if (k > 0) {
              // NOTE: Inserting ws tokens to keep even operator spacing in the resulting array
              results.push(" ", "&&", " ")
            }
            const [pre, op, post, exp] = binops[index]

            let endIndex
            if (k < chains.length - 1) {
              endIndex = chains[k + 1]
            } else {
              endIndex = i + 1
            }

            results = results.concat(first, ...binops.slice(start, endIndex))
            first = [exp].concat(binops.slice(index + 1, endIndex))
            start = endIndex
          })
        } else {
          // Advance start if there was no chain
          results = results.concat(first, ...binops.slice(start, i + 1))
          start = i + 1
        }

        chains.length = 0
      }
    }

    // Return an array of Rule names that correspond to the current call stack
    module.parsePosition = function() {
      let s = Error().stack.split(/\n    at /)
      s.shift()
      s = s.filter((e) => !e.match(/^eval/)).map((e) => e.split(' ')[0])
      s = s.slice(1, s.indexOf('Program') + 1)

      return s
    }

    module.prune = function(node) {
      if(node === null || node === undefined) return
      if(node.length === 0) return

      if (Array.isArray(node)) {
        const a = node
        .map((n) => module.prune(n))
        .filter((n) => !!n)

        if(a.length > 1)  return a
        if(a.length === 1) return a[0]
        return
      }

      if(node.children != null) {
        node.children = module.prune(node.children)
        return node
      }

      return node
    }

    // Trims the first single space from the spacing array or node's children if present
    // maintains $loc for source maps
    module.insertTrimmingSpace = function(spacing, c) {
      let target = spacing
      if (!target) return

      if (Array.isArray(target)) return module.insertTrimmingSpace(target[0], c)
      if (target.children) return module.insertTrimmingSpace(target.children[0], c)

      if (target.token) {
        target.token = target.token.replace(/^ ?/, c)
      }

      return spacing
    }

    // Split out leading newlines from the first indented line
    const initialSpacingRe = /^(?:\r?\n|\n)*((?:\r?\n|\n)\s+)/

    module.dedentBlockSubstitutions = function($0) {
      const [s, strWithSubstitutions, e] = $0

      if (strWithSubstitutions.length === 0) {
        return $0
      }

      let initialSpacing, i=0, l=strWithSubstitutions.length, results=[s]
      // Get initial spacing from the first string token if it is not a substitution
      const {token} = strWithSubstitutions[0]

      if (token) {
        initialSpacing = token.match(initialSpacingRe)
      } else {
        initialSpacing = false
      }

      while (i < l) {
        let segment = strWithSubstitutions[i]

        if (segment.token) {
          segment = module.dedentBlockString(segment, initialSpacing, false)
          if (i === 0) {
            // Trim leading newline
            segment.token = segment.token.replace(/^(\r?\n|\n)/, "")
          }
          if (i === l - 1) {
            // Trim trailing newline
            segment.token = segment.token.replace(/(\r?\n|\n)[ \t]*$/, "")
          }
          results.push(segment)
        } else {
          results.push(segment)
        }

        i++
      }

      results.push(e)
      return results
    }

    module.dedentBlockString = function({$loc, token: str}, spacing, trim=true) {
      // If string begins with a newline then indentation assume that it should be removed for all lines
      if (spacing == null) spacing = str.match(initialSpacingRe)

      if (spacing) {
        str = str.replaceAll(spacing[1], "\n")
        const l = spacing.length
        $loc.pos += l
        $loc.length -= l
      }

      if (trim) {
        // Remove leading newline
        str = str.replace(/^(\r?\n|\n)/, "")
        // Remove trailing newline
        .replace(/(\r?\n|\n)[ \t]*$/, "")
      }

      // escape backtick, $
      str = str.replace(/(`|\$\{)/g, "\\$1")

      return {
        $loc,
        token: str,
      }
    }

    // Gather child nodes that match a predicate
    // while recursing into nested expressions
    // without recursing into nested blocks/for loops
    function gatherNodes(node, predicate) {
      if (node == null) return []

      if (Array.isArray(node)) {
        return node.flatMap((n) => gatherNodes(n, predicate))
      }

      if (predicate(node)) {
        return [node]
      }

      switch(node.type) {
        case "BlockStatement":
          return []
        case "ForStatement":
          // Descend into expressions but not into declarations or the body of the for loop
          const isDec = node.declaration?.type === "Declaration"
          return node.children.flatMap((n) => {
            if (isDec && n === node.declaration) return []
            return gatherNodes(n, predicate)
          })
        default:
          return gatherNodes(node.children, predicate)
      }

      return []
    }

    function gatherRecursive(node, predicate) {
      if (node == null) return []

      if (Array.isArray(node)) {
        return node.flatMap((n) => gatherNodes(n, predicate))
      }

      if (predicate(node)) {
        return [node]
      }

      return gatherNodes(node.children, predicate)
    }

    module.processProgram = function(statements) {
      // Insert prelude
      statements.unshift(...module.prelude)

      if (module.config.autoVar) {
        createVarDecs(statements, [])
      }

      populateRefs(statements)
    }

    function findDecs(statements) {
      const declarationNames = gatherNodes(statements, (node) => {
        if(node.type === "Declaration") {
          return true
        }
      }).flatMap(d => d.names)

      return new Set(declarationNames)
    }

    function populateRefs(statements) {
      const refNodes = gatherNodes(statements, ({type}) => type === "Ref")
      const blockNodes = new Set(gatherNodes(statements, ({type}) => type === "BlockStatement"))
      const forNodes = gatherNodes(statements, ({type}) => type === "ForStatement")

      // Populate refs from inside out
      forNodes.forEach(({declaration, block}) => {
        // Need to include declarations with block because they share scope
        if (block.type === "BlockStatement") {
          populateRefs([declaration, ...block.children])
        } else { // single non-block statement
          populateRefs([declaration, ...block])
        }
        blockNodes.delete(block)
      })

      blockNodes.forEach(({expressions}) => populateRefs(expressions))

      if (refNodes.length) {
        // Find all ids within nested scopes
        const ids = gatherRecursive(statements, (s) => s.type === "Identifier")
        const names = new Set(ids.flatMap(({names}) => names || []))

        // Populate each ref
        refNodes.forEach((ref) => {
          const {type, base} = ref
          if (type !== "Ref") return

          ref.type = "Identifier"

          let n = 0
          let name = base

          // check for name collisions and increment name suffix
          while (names.has(name)) {
            n++
            name = `${base}${n}`
          }

          names.add(name)
          ref.children = ref.names = [name]
        })
      }
    }

    // CoffeeScript compatible automatic var insertion
    function createVarDecs(statements, scopes, pushVar) {
      // NOTE: var and let/const have different scoping rules
      // need to keep var scopes when entering functions and within a var scope keep
      // track of lexical scopes within blocks
      function hasDec(name) {
        return scopes.some((s) => s.has(name))
      }

      function findAssignments(statements, decs) {
        const assignmentStatements = gatherNodes(statements, (node) => {
          return node.type === "AssignmentExpression"
        })

        const undeclaredIdentifiers = assignmentStatements.flatMap((a) => {
          return a.names
        })

        // Unique, undeclared identifiers in this scope
        return undeclaredIdentifiers.filter((x, i, a) => {
          if (!hasDec(x)) return a.indexOf(x) === i
        })
      }

      // Let descendent blocks add the var at the outer enclosing function scope
      if (!pushVar) {
        pushVar = function(name) {
          varIds.push(name)
          decs.add(name)
        }
      }

      const decs = findDecs(statements)
      scopes.push(decs)
      const varIds = []
      findAssignments(statements, scopes)
      .forEach(pushVar)

      const fnNodes  = gatherNodes(statements, (s) => s.type === "FunctionExpression")
      const forNodes = gatherNodes(statements, (s) => s.type === "ForStatement")

      const blockNodes = new Set(gatherNodes(statements, (s) => s.type === "BlockStatement"))
      // Remove function blocks and for statements, they get handled separately because they have additional parameter scopes and lexical scopes to add
      fnNodes .forEach(({block}) => blockNodes.delete(block))
      forNodes.forEach(({block}) => blockNodes.delete(block))

      // recurse into nested blocks
      blockNodes.forEach((block) => {
        createVarDecs(block.expressions, scopes, pushVar)
      })

      // recurse into for loops
      forNodes.forEach(({block, declaration}) => {
        scopes.push(new Set(declaration.names))
        createVarDecs(block.expressions, scopes, pushVar)
        scopes.pop()
      })

      // recurse into nested functions
      fnNodes.forEach(({block, parameters}) => {
        scopes.push(new Set(parameters.names))
        createVarDecs(block.expressions, scopes)
        scopes.pop()
      })

      if (varIds.length) {
        // get indent from first statement
        const indent = statements[0][0]
        statements.unshift([indent, "var ", varIds.join(", "), "\n"])
      }
    }

    return $0

# Indentation

# Holds the last indent level in `module.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  ( "  " / "\t" )* ->
    const level = $1.length

    return {
      $loc,
      token: "".padStart(level * 2),
      level
    }

# Tracks current indentation without assuming that it should nest deeper
# Must be matched with PopIndent
TrackIndent
  "" ->
    module.indentLevels.push(module.currentIndent)

Samedent
  EOS? Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (level === currentIndent) {
      return $0
    }
    return $skip

IndentedFurther
  EOS? Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (level > currentIndent) {
      return $0
    }
    return $skip

# Indents one level deeper
# Must be matched with PopIndent
PushIndent
  "" ->
    module.currentIndent++
    if (module.verbose) {
      console.log("pushing indent", module.currentIndent)
    }
    module.indentLevels.push(module.currentIndent)

PopIndent
  "" ->
    if (module.verbose) {
      console.log("popping indent", module.indentLevels[module.indentLevels.length-1], "->", module.indentLevels[module.indentLevels.length-2])
    }
    module.indentLevels.pop()
    module.currentIndent = module.indentLevels[module.indentLevels.length-1]

Nested
  EOS?:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (module.verbose) {
      console.log("global indent", module.currentIndent)
      console.log("Indented", level, currentIndent)
    }
    if (level !== currentIndent) {
      if (module.verbose) {
        console.log("skipped nested")
      }
      return $skip
    }
    return $0
