# Civet: A successor to CoffeeScript and alternative to TypeScript
# much more 1-to-1 with es6

# ECMA Reference
# https://262.ecma-international.org/13.0/

Program
  Reset Init __ TopLevelStatement* __

TopLevelStatement
  EOS? ModuleItem StatementDelimiter

# https://262.ecma-international.org/#prod-Expression
Expression
  # CommaOperator
  # https://262.ecma-international.org/#sec-comma-operator
  # NOTE: Eliminated left recursion
  AssignmentExpression (__ Comma AssignmentExpression)* ->
    if($2.length == 0) return $1
    return $0

# https://262.ecma-international.org/#prod-Arguments
Arguments
  OpenParen ArgumentList? ( __ Comma )? __ CloseParen
  # NOTE: Added spacing based implicit function application
  # Trailing (__ MemberExpressionRest)* is to capture trailing .someMethod and bind them at the right place
  ImplicitApplication

ArgumentsWithTrailingCallExpressions
  # Since this is recursive Arguments must consume input to avoid infinite recursion
  # NOTE: Do not allow trailing template literals to match
  TrackIndent (( Arguments ( &EOS Samedent !Backtick CallExpressionRest )* PopIndent ) / PopIndent) ->
    // No match, only restored indent
    if (!$2) return $skip
    return $2

# https://262.ecma-international.org/#prod-ArgumentList
ArgumentList
  # NOTE: Added nested arguments on separate new lines
  &EOS NestedArgumentList
  InlineArgumentExpressions

NestedArgumentList
  PushIndent NestedArgument*:args PopIndent ->
    if (args.length) return args
    return $skip

NestedArgument
  Nested InlineArgumentExpressions ParameterElementDelimiter

InlineArgumentExpressions
  # NOTE: Eliminated left recursion
  ( DotDotDot? AssignmentExpressionRest ) ( __ Comma TrailingComment* DotDotDot? AssignmentExpressionRest )* ->
    if($2.length == 0) return $1
    return $0

ImplicitApplication
  # Space / indentation based function application
  # Function application:
  # a b => a(b)
  # a b, c, d => a(b, c, d)
  # x y z => x(y(z))
  ApplicationStart ArgumentList InsertCloseParen

# Start of function application, inserts an open parenthesis, maintains spacing and comments when possible
ApplicationStart
  !EOS _:spacing !AdditionalReservedWords ->
    return module.insertTrimmingSpace(spacing, "(")
  # Nested application for nested objects
  # someMethod => someMethod({
  #   a: b          a: b
  #               })
  #
  # IndentedApplicationAllowed gets turned of inside if conditions and switch conditions to prevent
  # indentation based function application from being used inside them. It is a bit of a hack.
  IndentedApplicationAllowed &NestedObjectLiteral InsertOpenParen -> $3

IndentedApplicationAllowed
  "" ->
    if (module.suppressIndentedApplication) return $skip
    return

BinaryOpExpression
  UnaryExpression (__ BinaryOp __ UnaryExpression)* ->
    if ($2.length) {
      return module.expandChainedComparisons($0)
    }

    return $1

# https://262.ecma-international.org/#prod-UnaryExpression
UnaryExpression
  # NOTE: Eliminated left recursion
  UnaryOp*:pre UpdateExpression:exp UnaryPostfix?:post ->
    // Handle "?" postfix
    if (post?.token === "?") {
      // v1.1 Can remove parens when unnecessary once exp returns a full AST node to determine if they are actually needed
      return ["(", pre, "(", exp, ") != null)"]
    }

    const result = [pre, exp, post]
    if (!post) result.pop()
    if (!pre.length) result.shift()
    if (result.length === 1) return result[0]

    return result

UnaryPostfix
  QuestionMark
  ( __ As Type )+ -> { ts: true, children: $0 }

# https://262.ecma-international.org/#prod-UpdateExpression
UpdateExpression
  # NOTE: Not allowing whitespace betwen prefix and postfix increment operators and operand
  UpdateExpressionSymbol UnaryExpression
  LeftHandSideExpression UpdateExpressionSymbol? ->
    if ($2) return $0
    return $1

UpdateExpressionSymbol
  ("++" / "--") ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-AssignmentExpression
AssignmentExpression
  # NOTE: Try to match a single line assignment expression before matching newline then assignment expression
  TrailingComment* AssignmentExpressionRest ->
    if ($1.length) return $0
    return $2
  __ AssignmentExpressionRest

AssignmentExpressionRest
  AwaitExpression
  YieldExpression
  (Async __)? ArrowFunction

  # NOTE: Eliminated left recursion
  # NOTE: Consolidated assignment ops
  (__ LeftHandSideExpression __ AssignmentOp)+ Expression ->
    // Splice assignment
    // TODO: this is kind of bonkers
    // TODO: Handle multiple assignments
    const lastAssignment = $1[$1.length-1]
    // TODO: Handle optional assignment
    if (lastAssignment[3].token === "=") {
      const lhs = lastAssignment[1]
      if (Array.isArray(lhs) && lhs.length > 1) {
        const props = lhs[lhs.length-1]

        if (Array.isArray(props)) {
          const lastProp = props[props.length-1]

          if(lastProp.type === "SliceExpression") {
            const {start, end, children: c} = lastProp
            // TODO: don't lose as many source mappings
            c[0].token = ".splice("
            c[1] = start
            c[2] = ", "
            if (end)
              c[3] = [end, " - ", start]
            else
              c[3] = ["1/0"]
            c[4] = [", ...", $2]
            c[5] = ")"

            // Remove assignment token
            lastAssignment.pop()
            if (module.isWhitespaceOrEmpty(lastAssignment[2])) lastAssignment.pop()
            return $1
          }
        }
      }
    }

    return {
      type: "AssignmentExpression", children: $0
    }

  ConditionalExpression

AwaitExpression
  Await TrailingComment* AssignmentExpression

YieldExpression
  Yield ( TrailingComment* Star )? AssignmentExpression

# https://262.ecma-international.org/#prod-ArrowFunction
ArrowFunction
  ThinArrowFunction
  Parameters ReturnTypeSuffix?:suffix FatArrow FatArrowBody:expOrBlock ->
    const isVoid = suffix?.children?.[1]?.[0]?.[1]?.token === "void"
    const isBlock = expOrBlock.type === "BlockStatement"
    if (module.config.implicitReturns && !isVoid && isBlock) {
      module.addImplicitReturns(expOrBlock)
    }

    return {
      type: "FunctionExpression",
      children: $0,
    }

FatArrow
  # Ensures at least one space before arrow
  __:ws "=>" ->
    if (!ws.length)
      return " =>"
    return $0

# NOTE Different from
# https://262.ecma-international.org/#prod-ConciseBody
FatArrowBody
  __ OpenBrace EOS NestedBlockExpressions:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  AssignmentExpression
  EmptyBlock

# https://262.ecma-international.org/#prod-ConditionalExpression
ConditionalExpression
  ShortCircuitExpression ( __ QuestionMark AssignmentExpression __ Colon AssignmentExpression)? ->
    if ($2) return $0
    return $1

# https://262.ecma-international.org/#prod-ShortCircuitExpression
ShortCircuitExpression
  # NOTE: We don't need to track the precedence of all the binary operators so they all collapse into this
  BinaryOpExpression

# https://262.ecma-international.org/#prod-PrimaryExpression
PrimaryExpression
  This
  IdentifierReference
  Literal
  ArrayLiteral
  ObjectLiteral
  FunctionExpression
  ClassExpression
  RegularExpressionLiteral
  TemplateLiteral
  # https://262.ecma-international.org/#prod-ParenthesizedExpression
  # NOTE: Currently ignoring early error checking in https://262.ecma-international.org/#prod-CoverParenthesizedExpressionAndArrowParameterList
  OpenParen Expression __ CloseParen
  # https://facebook.github.io/jsx/#sec-jsx-PrimaryExpression
  JSXElement
  JSXFragment

# https://262.ecma-international.org/#prod-ClassDeclaration
ClassDeclaration
  # NOTE: skipping syntax directed operation for now
  ClassExpression

# https://262.ecma-international.org/#prod-ClassExpression
ClassExpression
  Class ( BindingIdentifier )? ( __ ClassHeritage )? ClassBody

# https://262.ecma-international.org/#prod-ClassHeritage
ClassHeritage
  # ExtendsToken __ LeftHandSideExpression
  # NOTE: This is a subset of member expression that doesn't have spaced function application
  # TODO: there are some other LeftHandSideExpressions that are valid here but aren't yet supported (new, super, import expression)
  ExtendsToken __ MemberExpression

ExtendsToken
  # NOTE: Added "<" extends shorthand
  "<" ->
    return { $loc, token: "extends" }
  "extends" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-ClassBody
# NOTE: Nesting and indentation sensitive
ClassBody
  __ OpenBrace (EOS NestedClassElements)? __ CloseBrace
  InsertOpenBrace EOS NestedClassElements InsertNewline InsertIndent InsertCloseBrace

NestedClassElements
  PushIndent NestedClassElement*:elements PopIndent ->
    if (!elements.length) return $skip
    return elements

NestedClassElement
  Nested ClassElement StatementDelimiter

# https://262.ecma-international.org/#prod-ClassElement
ClassElement
  # NOTE: Combined optional static and Method/Field definition
  (Static TrailingComment*)? ( MethodDefinition / FieldDefinition )
  # ClassStaticBlock
  Static BracedBlock

# https://262.ecma-international.org/#prod-FieldDefinition
FieldDefinition
  # NOTE: Added readonly semantic equivalent of const field assignment
  InsertReadonly:r ClassElementName TypeSuffix? __ ConstAssignment:ca AssignmentExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    r.children[0].$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return $0

  ClassElementName TypeSuffix? Initializer?

This
  "this" ->
    return { $loc, token: $1 }
  # NOTE: Added @identifier shorthand, also works for private identifiers
  AtAccessor ( "#"? IdentifierName )
  # NOTE: Added '@' as a 'this' shorthand
  "@" ->
    return { $loc, token: "this" }

AtAccessor
  "@" ->
    return { $loc, token: "this." }

# https://262.ecma-international.org/#prod-LeftHandSideExpression
LeftHandSideExpression
  NewExpression
  CallExpression
  # NOTE: OptionalExpression is merged into CallExpression

# https://262.ecma-international.org/#prod-NewExpression
NewExpression
  # NOTE: Eliminated left recursion
  # NOTE: Changed to CallExpression to handle arguments
  (New __)+ CallExpression

# https://262.ecma-international.org/#prod-CallExpression
CallExpression
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  "super" ArgumentsWithTrailingCallExpressions
  "import" __ OpenParen AssignmentExpression __ CloseParen
  MemberExpression CallExpressionRest* ->
    if ($2.length) return $0
    return $1

CallExpressionRest
  MemberExpressionRest
  TemplateLiteral
  # NOTE: Tracking trailing member expressions based on indentation level for implicit arguments
  (OptionalShorthand / NonNullAssertion)? ArgumentsWithTrailingCallExpressions

# NOTE: Added shorthand x?(3) -> x?.(3)
OptionalShorthand
  (QuestionMark ( Dot / InsertDot ))

NonNullAssertion
  "!" -> { ts: true, children: $1 }

# Reserved words that will prevent spaced function application
# ie: the 'of' in 'for x of ...'
AdditionalReservedWords
  /(of)(?!\p{ID_Continue}|[\u200C\u200D$])/

# https://262.ecma-international.org/#prod-MemberExpression
MemberExpression
  # NOTE: "new" MemberExpression Arguments seems to be handled fine by other rules already
  # NOTE: Eliminated left recursion
  PrimaryExpression MemberExpressionRest* ->
    if ($2.length) return $0
    return $1
  TrailingComment* SuperProperty
  TrailingComment* MetaProperty

MemberExpressionRest
  # NOTE: Added shorthand x?[3] -> x?.[3]
  ( OptionalShorthand / NonNullAssertion )? MemberBracketContent ->
    if ($1) return $0
    return $2
  # NOTE: Combined Optional and Property access
  # TODO: this doesn't yet work for arbitrarily deep nesting, only the first level
  ( &EOS IndentedFurther )? PropertyAccess
  # NOTE: Added CoffeeScript :: prototype shorthand
  ( &EOS IndentedFurther )? "::" IdentifierName?:id ->
    if (id)
      return [".prototype.", id]
    return ".prototype"
  # NOTE: Added TypeScript '!' non-null assertion
  NonNullAssertion

# Handles indexing and slicing
MemberBracketContent
  OpenBracket Expression ( ( DotDotDot / DotDot ) Expression? )? __ CloseBracket ->
    // Some kind of slice
    if ($3) {
      const sep = $3[0]
      const end = $3[1]
      const inclusive = sep.token === ".."

      sep.token = ", "
      $1.token = ".slice("
      $5.token = ")"

      if (!end) {
        return {
          type: "SliceExpression",
          start: $2,
          end: undefined,
          children: [$1, $2, $4, $5]
        }
      }

      if (inclusive) {
        return {
          type: "SliceExpression",
          start: $2,
          end: ["1 + ", end],
          children: [$1, $2, sep, ["1 + ", end, " || 1/0"], $4, $5]
        }
      }

      return {
        type: "SliceExpression",
        start: $2,
        end: end,
        children: [$1, $2, sep, end, $4, $5]
      }
    }

    // Regular index `[exp]`
    return $0

PropertyAccess
  ( QuestionMark / NonNullAssertion )? Dot ( IdentifierName / PrivateIdentifier )

SuperProperty
  "super[" Expression __ CloseBracket

MetaProperty
  New Dot Target
  "import.meta" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-FormalParameters
# The parameters in a function definition
Parameters
  NonEmptyParameters
  "" ->
    return { $loc, token: "()" }

NonEmptyParameters
  # NOTE: BindingElement -> ParameterElement
  TypeParameters? OpenParen ParameterElement* FunctionRestParameter? __ CloseParen

# https://262.ecma-international.org/#prod-FunctionRestParameter
FunctionRestParameter
  __ BindingRestElement TypeSuffix?

# NOTE: Similar to BindingElement but appears in formal parameters list
ParameterElement
  # NOTE: Merged in SingleNameBinding
  __ (BindingIdentifier / BindingPattern) TypeSuffix? Initializer? ParameterElementDelimiter

ParameterElementDelimiter
  _* Comma
  &( __ ")" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-BindingIdentifier
BindingIdentifier
  __ Identifier

# https://262.ecma-international.org/#prod-BindingPattern
BindingPattern
  __ ObjectBindingPattern
  __ ArrayBindingPattern

# https://262.ecma-international.org/#prod-ObjectBindingPattern
# NOTE: Simplified from spec
ObjectBindingPattern
  # NOTE: Added indentation based binding properties
  OpenBrace &EOS NestedBindingProperties __ CloseBrace
  OpenBrace BindingProperty* ( __ BindingRestProperty )? __ CloseBrace

# https://262.ecma-international.org/#prod-ArrayBindingPattern
# NOTE: Simplified from spec
ArrayBindingPattern
  # Note: Added indentation based binding elements
  OpenBracket &EOS NestedBindingElements __ CloseBracket
  OpenBracket (BindingElement / Elision)* ( __ BindingRestElement )? __ CloseBracket

NestedBindingProperties
  PushIndent NestedBindingProperty*:props ( Nested BindingRestProperty )?:rest PopIndent ->
    if (!props.length) return $skip
    if (rest) props.push(rest)
    return props

NestedBindingProperty
  Nested BindingProperty

# https://262.ecma-international.org/#prod-BindingProperty
BindingProperty
  __ PropertyName __ Colon (BindingIdentifier / BindingPattern) Initializer? ObjectPropertyDelimiter
  BindingIdentifier Initializer? ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-BindingRestProperty
BindingRestProperty
  DotDotDot BindingIdentifier

NestedBindingElements
  PushIndent NestedBindingElement*:props ( Nested BindingRestElement )?:rest PopIndent ->
    if (!props.length) return $skip
    if (rest) props.push(rest)
    return props

NestedBindingElement
  Nested BindingElement

# https://262.ecma-international.org/#prod-BindingElement
BindingElement
  # NOTE: Merged in SingleNameBinding
  __ (BindingIdentifier / BindingPattern) Initializer? ArrayElementDelimiter

# https://262.ecma-international.org/#prod-BindingRestElement
BindingRestElement
  DotDotDot __ ( BindingIdentifier / BindingPattern )

# https://262.ecma-international.org/#prod-FunctionDeclaration
FunctionDeclaration
  FunctionExpression

FunctionSignature
  # NOTE: Merged in async and generator with optionals
  ( Async __ )? Function ( Star __ )? ( BindingIdentifier )? __ Parameters ReturnTypeSuffix?

# https://262.ecma-international.org/#prod-FunctionExpression
FunctionExpression
  # NOTE: Added CoffeeScript thin arrow function shorthand
  ThinArrowFunction
  # TODO: block isn't actually optional in FunctionExpression only in declarations/TS overloads
  FunctionSignature BracedBlock?:block ->
    // TS Function overloads
    if (!block) {
      return {
        type: "FunctionDeclaration",
        ts: true,
        children: $1
      }
    }

    const suffix = $1[$1.length - 1]
    const isVoid = suffix?.children?.[1]?.[0]?.[1]?.token === "void"
    if (module.config.implicitReturns && !isVoid) {
      module.addImplicitReturns(block)
    }

    $1.push(block)
    return {
      type: "FunctionExpression",
      children: $1,
    }

ThinArrowFunction
  Parameters:params ReturnTypeSuffix?:suffix _* Arrow:arrow BracedOrEmptyBlock:block ->
    const isVoid = suffix?.children?.[1]?.[0]?.[1]?.token === "void"
    if (module.config.implicitReturns && !isVoid) {
      block = module.addImplicitReturns(block)
    }

    return {
      type: "FunctionExpression",
      children: [
        { $loc: arrow.$loc, token: "function" },
        params,
        suffix,
        block
      ]
    }

Arrow
  "->" ->
    return { $loc, token: $1}

# NOTE: This is the body of if/else/for etc.
Block
  __ OpenBrace EOS NestedBlockExpressions:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  Statement
  __ Statement

BracedOrEmptyBlock
  BracedBlock
  EmptyBlock

EmptyBlock
  # Implied empty block
  InsertOpenBrace InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: [],
    children: $0,
  }

# This is a block that must include braces (function body, try/catch/finally)
BracedBlock
  __ OpenBrace EOS NestedBlockExpressions:exps __ CloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedBlockExpressions:exps InsertNewline InsertIndent InsertCloseBrace -> {
    type: "BlockStatement",
    expressions: exps,
    children: $0,
  }
  # One liner
  InsertOpenBrace !EOS __ Statement:s InsertSpace InsertCloseBrace ->
    return {
      type: "BlockStatement",
      expressions: [s],
      children: $0,
    }

SingleNestedExpression
  # NOTE: Don't insert a statement delimiter for single nested expression
  # NOTE: this whole back half is mainly to guarantee we call PopIndent exactly once whether we've matched or not
  PushIndent (Nested Expression StatementDelimiter)?:exp ( (!(Nested Expression) PopIndent) / PopIndent ) ->
    if (exp) return exp
    return $skip

NestedBlockExpressions
  PushIndent BlockExpression*:exps PopIndent ->
    if (!exps.length) return $skip
    return exps

BlockExpression
  Nested StatementListItem StatementDelimiter

# https://262.ecma-international.org/#prod-Literal
Literal
  NullLiteral
  BooleanLiteral
  NumericLiteral
  StringLiteral

# https://262.ecma-international.org/#prod-NullLiteral
NullLiteral
  "null" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-BooleanLiteral
BooleanLiteral
  CoffeeScriptBooleanLiteral
  "true" / "false" ->
    return { $loc, token: $1 }

CoffeeScriptBooleanLiteral
  "yes" / "on" ->
    return { $loc, token: "true" }
  "no" / "off" ->
    return { $loc, token: "false" }

Comma
  _* Comma _*

# https://262.ecma-international.org/#prod-Identifier
Identifier
  !ReservedWord IdentifierName -> $2

# https://262.ecma-international.org/#prod-IdentifierName
IdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$])*/ ->
    return {
      type: "Identifier",
      $loc: $loc,
      token: $0,
    }

# https://262.ecma-international.org/#prod-IdentifierReference
IdentifierReference
  Identifier

# https://262.ecma-international.org/#prod-ArrayLiteral
ArrayLiteral
  OpenBracket NestedElementList __ CloseBracket
  OpenBracket ElementList __ CloseBracket

NestedElementList
  PushIndent NestedElement*:elements PopIndent ->
    if (elements.length)
      return elements
    return $skip

NestedElement
  Nested InlineElementList ArrayElementDelimiter

ArrayElementDelimiter
  _* Comma
  # NOTE: Don't insert comma before closing bracket
  # Ideally it would be nice to insert a trailing comma before newline followed by closing bracket, but in practice
  # it is difficult to keep the correct number of commas for elision elements. This is also closer to keeping source
  # verbatim.
  &( __ "]" )
  &EOS ->
    return { $loc, token: "," }

# https://262.ecma-international.org/#prod-ElementList
# NOTE: Modified and simplified from the spec
ElementList
  ArrayElementExpression ( __ Comma __ ArrayElementExpression )*

InlineElementList
  ArrayElementExpression ( _* Comma _* ArrayElementExpression )*

# NOTE: Modified and simplified from the spec
ArrayElementExpression
  ((DotDotDot __ )? AssignmentExpression)?

# https://262.ecma-international.org/#prod-Elision
Elision
  # NOTE: The repetition must be handled from outside rather than using left recursion here
  __ Comma

# https://262.ecma-international.org/#prod-ObjectLiteral
# NOTE: Slightly simplified from spec
ObjectLiteral
  OpenBrace &EOS NestedPropertyDefinitions __ CloseBrace
  OpenBrace __ PropertyDefinitionList __ (Comma __)? CloseBrace
  OpenBrace __ CloseBrace
  NestedObjectLiteral

NestedObjectLiteral
  InsertOpenBrace &EOS NestedPropertyDefinitions InsertNewline InsertIndent InsertCloseBrace

NestedPropertyDefinitions
  PushIndent NestedPropertyDefinition*:defs PopIndent ->
    if(!defs.length) return $skip
    return defs

NestedPropertyDefinition
  # TODO: This may be a little weird/ambiguous with single identifier shorthand
  Nested PropertyDefinition ObjectPropertyDelimiter

ObjectPropertyDelimiter
  _* Comma
  # Object closing delimits the property
  &( __ "}" )
  &EOS ->
    return { $loc, token: "," }

PropertyDefinitionList
  PropertyDefinition (__ Comma __ PropertyDefinition)*

# https://262.ecma-international.org/#prod-PropertyDefinition
PropertyDefinition
  # NOTE: CoverInitializedName early error doesn't seem necessary with this parser
  PropertyName __ Colon AssignmentExpression
  MethodDefinition
  DotDotDot AssignmentExpression
  # NOTE: this needs to be at the bottom to prevent shadowing PropertyName
  IdentifierReference

PropertyName
  # https://262.ecma-international.org/#prod-LiteralPropertyName
  NumericLiteral
  StringLiteral
  IdentifierName
  # https://262.ecma-international.org/#prod-ComputedPropertyName
  OpenBracket AssignmentExpression __ "]"

# https://262.ecma-international.org/#prod-MethodDefinition
MethodDefinition
  # NOTE: Not adding extra validation using PropertySetParameterList
  MethodSignature:sig BracedBlock:block ->
    const isConstructor = sig.name       === "constructor"
    const isVoid        = sig.returnType === "void"
    const isSet         = sig.modifier   === "set"

    if (module.config.implicitReturns && !isConstructor && !isSet && !isVoid) {
      block = module.addImplicitReturns(block)
    }

    return $0

MethodModifier
  # NOTE: Merged get/set definitions
  GetOrSet TrailingComment*
  # NOTE: Merged async and generator into MethodModifier
  ( Async __ ) ( Star __ )?
  Star __
  Async __

# TypeScript method signature
MethodSignature
  ConstructorShorthand Parameters ->
    return {
      type: "MethodSignature",
      children: $0,
      name: $1.token,
      returnType: undefined,
    }

  MethodModifier? ClassElementName:name _* NonEmptyParameters ReturnTypeSuffix?:suffix ->
    // Normalize name so we can check if it is `constructor`
    name = name.token.match(/^(?:"|')/) ? name.token.slice(1, -1) : name.token

    return {
      type: "MethodSignature",
      children: $0,
      name: name,
      modifier: $1?.[0]?.token, // get/set
      // TODO: get return type from type annotation
      returnType: undefined,
    }

ClassElementName
  PropertyName
  PrivateIdentifier

PrivateIdentifier
  $("#" IdentifierName) ->
    return {
      $loc: $loc,
      token: $1,
    }

# https://262.ecma-international.org/#prod-GeneratorDeclaration
# https://262.ecma-international.org/#prod-GeneratorExpression
# NOTE: Merged GeneratorExpression and GeneratorDeclaration into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncFunctionDeclaration
# https://262.ecma-international.org/#prod-AsyncFunctionExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorDeclaration
# https://262.ecma-international.org/#prod-AsyncGeneratorExpression
# NOTE: Merged into FunctionExpression

# https://262.ecma-international.org/#prod-AsyncGeneratorMethod
# https://262.ecma-international.org/#prod-AsyncGeneratorBody
# https://262.ecma-international.org/#prod-AsyncMethod
# https://262.ecma-international.org/#prod-AsyncFunctionBody
# https://262.ecma-international.org/#prod-GeneratorMethod
# https://262.ecma-international.org/#prod-GeneratorBody
# NOTE: Merged into MethodDefinition

# https://262.ecma-international.org/#prod-AssignmentOperator
AssignmentOp
  AssignmentOpSymbol ->
    return { $loc, token: $1 }

AssignmentOpSymbol
  "**="
  "*="
  "/="
  "%="
  "+="
  "-="
  "<<="
  ">>>="
  ">>="
  "&&="
  "&="
  "^="
  "||="
  "|="
  "??="
  "?=" -> "??="
  "="

BinaryOp
  BinaryOpSymbol ->
    return { $loc, token: $1 }

# NOTE: Condensed binary operator symbols into one rule
BinaryOpSymbol
  "**"
  "*"
  "/"
  "%"
  "+"
  "-"
  "<="
  ">="
  "<<"
  "<"
  ">>>"
  ">>"
  ">"
  "!=="
  # NOTE: CoffeeScript converts "!=" -> "!=="
  # Convert if CoffeeScript compat flag is set
  "!=" ->
    if(module.config.coffeeEq) return "!=="
    return $1
  "isnt" NonIdContinue ->
    if(module.config.coffeeIsnt) return "!=="
    return $skip
  "is" NonIdContinue -> "==="
  "==="
  # NOTE: CoffeeScript converts "==" -> "==="
  # Convert if CoffeeScript compat flag is set
  "==" ->
    if(module.config.coffeeEq) return "==="
    return $1
  "and" NonIdContinue -> "&&"
  "&&"
  "or" NonIdContinue -> "||"
  "||"
  "??"
  "instanceof" NonIdContinue ->
    return $1
  "in" NonIdContinue ->
    return $1
  "&"
  "^"
  "|"

UnaryOp
  [!~+-] ->
    return { $loc, token: $0 }
  ( Delete / Void / Typeof ) __

# https://262.ecma-international.org/#prod-ModuleItem
ModuleItem
  ImportDeclaration
  ExportDeclaration
  StatementListItem

# https://262.ecma-international.org/#prod-StatementListItem
StatementListItem
  Declaration
  # NOTE: Added postfix conditionals
  Statement:statement TrailingComment*:ws PostfixStatement?:post ->
    if (post) {
      post.children.push(statement)
      // This removes trailing whitespace for easier testing
      if (!module.isWhitespaceOrEmpty(ws)) post.children.push(ws)
      return post
    }
    return statement

PostfixStatement
  ForClause
  IfClause
  LoopClause
  UnlessClause
  WhileClause

# https://262.ecma-international.org/#prod-Statement
Statement
  KeywordStatement
  BlockStatement
  VariableStatement
  IfStatement
  IterationStatement
  SwitchStatement
  TryStatement

  EmptyStatement
  ExpressionStatement

  # NOTE: no WithStatement
  # NOTE: no LabelledStatement

# NOTE: EmptyStatement handled differently than spec, consuming inline whitespace and comments then asserting following semi-colon
EmptyStatement
  TrailingComment* &";" -> { type: "EmptyStatement", children: $1 }

# https://262.ecma-international.org/#prod-BlockStatement
BlockStatement
  __ OpenBrace EOS NestedBlockExpressions:exps __ CloseBrace -> {
    type: "BlockStatement",
    children: $0,
    expressions: exps,
  }

# https://262.ecma-international.org/#prod-IfStatement
IfStatement
  # NOTE: Added paren-less condition
  # NOTE: Block isn't Statement so we can handle implied braces by nesting
  IfClause:clause Block:block ( __ Else Block )?:e ->
    clause.children.push(block)
    if (e) clause.children.push(e)
    return clause
  UnlessClause:clause Block:block ->
    clause.children.push(block)
    return clause

IfClause
  If Condition -> { type: "IfStatement", children: $0 }

UnlessClause
  Unless:kind Condition:condition ->
    // Rewrite unless to if
    condition.forEach((c) => {
      if (!c) return
      if (c.token === "(") c.token = "(!("
      if (c.token === ")") c.token = "))"
    })
    kind.token = "if"

    return {
      type: "IfStatement",
      children: [kind, condition],
    }

# https://262.ecma-international.org/#prod-IterationStatement
IterationStatement
  # NOTE: Added `loop` from CoffeeScript
  LoopStatement
  DoWhileStatement
  WhileStatement
  ForStatement

# NOTE: Added from CoffeeScript
LoopStatement
  LoopClause:clause Block:block ->
    clause.children.push(block)
    return clause

LoopClause
  Loop -> { type: "IterationStatement", children: $0 }

# https://262.ecma-international.org/#prod-DoWhileStatement
DoWhileStatement
  # NOTE: Condition provides optional parens
  Do BracedBlock __ WhileClause -> { type: "IterationStatement", children: $0 }

# https://262.ecma-international.org/#prod-WhileStatement
WhileStatement
  # NOTE: Condition provides optional parens
  WhileClause:clause Block:block ->
    clause.children.push(block)
    return clause

WhileClause
  ( While / Until ):kind Condition:cond ->
    if (kind.token === "until") {
      cond[1] = "(!("
      cond[cond.length-1] = "))"
      kind.token = "while"
      $0 = [kind, cond]
    }

    return {
      type: "IterationStatement",
      children: $0
    }

# https://262.ecma-international.org/#prod-ForStatement
# https://262.ecma-international.org/#prod-ForInOfStatement
# NOTE: Merged into single rule
ForStatement
  ForClause:clause Block:block ->
    clause.children.push(block)
    return clause

ForClause
  For __ ForStatementControl  -> {
    type: "IterationStatement",
    children: $0,
  }

ForStatementControl
  # https://262.ecma-international.org/#prod-ForStatement
  OpenParen __       ( LexicalDeclaration / VariableStatement / Expression? ) __ Semicolon Expression? Semicolon Expression? __ CloseParen
  # NOTE: Added optional parens
  InsertOpenParen __ ( LexicalDeclaration / VariableStatement / Expression? ) __ Semicolon Expression? Semicolon (!EOS Expression)? InsertCloseParen

  # https://262.ecma-international.org/#prod-ForInOfStatement
  # NOTE: Consolidated declarations
  OpenParen __    ForInOfDeclaration __ In Expression __ CloseParen
  # NOTE: Added optional parens
  InsertOpenParen ForInOfDeclaration __ In Expression InsertCloseParen
  # NOTE: Consolidated optional 'await' and declarations
  ( Await __ )? OpenParen __    ForInOfDeclaration __ Of AssignmentExpression __ CloseParen
  # NOTE: Added optional parens
  ( Await __ )? InsertOpenParen ForInOfDeclaration __ Of AssignmentExpression InsertCloseParen

# NOTE: Consolidated declarations
ForInOfDeclaration
  Var ForBinding
  ForDeclaration
  LeftHandSideExpression

# https://262.ecma-international.org/#prod-ForDeclaration
ForDeclaration
  LetOrConst NonIdContinue ForBinding
  # NOTE: Added default implicit const to for bindings
  # NOTE: the assertion is a bit of a hack to prevent valid LHS expressions from only parsing the identifier and matching this rule
  # i.e. a.x would match as identifier `a` without this lookahead
  InsertConst ForBinding /(?=[\s\)])/

# https://262.ecma-international.org/#prod-ForBinding
ForBinding
  BindingIdentifier
  BindingPattern

# https://262.ecma-international.org/#prod-SwitchStatement
SwitchStatement
  Switch Condition CaseBlock -> {
    type: "SwitchStatement",
    children: $0
  }

# https://262.ecma-international.org/#prod-CaseBlock
CaseBlock
  __ OpenBrace &EOS NestedCaseClauses:clauses __ CloseBrace ->
    $0.splice(2, 1)

    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

  # NOTE: Added optional braces with nesting
  &EOS InsertOpenBrace NestedCaseClauses:clauses InsertNewline InsertIndent InsertCloseBrace ->
    $0.shift()

    return {
      type: "CaseBlock",
      clauses: clauses,
      children: $0,
    }

NestedCaseClauses
  PushIndent NestedCaseClause*:clauses PopIndent ->
    if (clauses.length) return clauses
    return $skip

NestedCaseClause
  Nested CaseClause ->
    // Bring the indent into the clause
    $2.children.unshift($1)
    return $2

# https://262.ecma-international.org/#prod-CaseClause
CaseClause
  # NOTE: This differs from ESTree significantly to be easier to work with for implicit returns
  Case CaseExpressionList ( NestedBlockExpressions / NoExpressions ):exps -> {
    type: "CaseClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Added "when" from CoffeeScript. `when` always inserts `break;`.
  When CaseExpressionList NestedBlockExpressions:exps InsertBreak -> {
    type: "WhenClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Merged in default clause
  Default ImpliedColon ( NestedBlockExpressions / NoExpressions ):exps -> {
    type: "DefaultClause",
    expressions: exps,
    children: $0
  }
  # NOTE: Added else from CoffeesScript
  Else ImpliedColon NestedBlockExpressions:exps ->
    $1.token = "default"
    return {
      type: "DefaultClause",
      expressions: exps,
      children: $0
    }

CaseExpressionList
  ( _* ExpressionWithIndentedApplicationSuppressed ImpliedColon ) ( __ Comma ExpressionWithIndentedApplicationSuppressed ImpliedColon )* ->
    // Convert comma separated expression list to `case <exp>:`
    const result = $2.map(([ws, _comma, exp, col]) => {
      module.insertTrimmingSpace(exp, "")

      if (ws.length) return [module.insertTrimmingSpace("case ", ws), exp, col]
      return ["case ", exp, col]
    })
    result.unshift($1)

    return result

NoExpressions
  "" -> []

ImpliedColon
  __ Colon
  "" ->
    return { $loc, token: ":" }

# https://262.ecma-international.org/#prod-TryStatement
TryStatement
  Try:t BracedBlock:b CatchClause?:c Finally?:f ->
    if (!c && !f) {
      return {
        type: "TryStatement",
        children: [t, b, " catch(e) {}"]
      }
    }

    return {
      type: "TryStatement",
      children: [t, b, c, f]
    }

# https://262.ecma-international.org/#prod-Catch
CatchClause
  __ Catch CatchBind? BracedBlock

# NOTE: Added optional parentheses to catch binding
CatchBind
  __ OpenParen __ CatchParameter __ CloseParen
  !EOS TrailingComment* InsertOpenParen CatchParameter InsertCloseParen

# https://262.ecma-international.org/#prod-Finally
Finally
  __ "finally" BracedBlock

# https://262.ecma-international.org/#prod-CatchParameter
CatchParameter
  BindingIdentifier
  BindingPattern

# An expression with explicit or implied parentheses, for use in if/while
Condition
  __ OpenParen Expression __ CloseParen
  !EOS __ InsertOpenParen ExpressionWithIndentedApplicationSuppressed InsertCloseParen ->
    $0.shift()
    return $0

ExpressionWithIndentedApplicationSuppressed
  SuppressIndentedApplication AssignmentExpression?:exp ->
    module.suppressIndentedApplication = false

    if (exp) return exp
    return $skip

SuppressIndentedApplication
  "" ->
    module.suppressIndentedApplication = true

# https://262.ecma-international.org/#prod-ExpressionStatement
ExpressionStatement
  # NOTE: semi-colons are being handled elsewhere
  # NOTE: Shouldn't need negative lookahead if shadowed in the proper order
  Expression

KeywordStatement
  # https://262.ecma-international.org/#prod-BreakStatement
  # NOTE: no label
  "break" NonIdContinue -> {
    type: "BreakStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ContinueStatement
  # NOTE: no label
  "continue" NonIdContinue -> {
    type: "ContinueStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#sec-debugger-statement
  "debugger" NonIdContinue -> {
    type: "DebuggerStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ReturnStatement
  Return MaybeNestedExpression? -> {
    type: "ReturnStatement",
    children: $0,
  }

  # https://262.ecma-international.org/#prod-ThrowStatement
  Throw Expression -> {
    type: "ThrowStatement",
    children: $0,
  }

MaybeNestedExpression
  !EOS TrailingComment* Expression
  &EOS ObjectLiteral

# https://262.ecma-international.org/#prod-ImportDeclaration
ImportDeclaration
  "import type" NonIdContinue __ ImportClause __ FromClause -> { ts: true, children: $0 }
  Import __ ImportClause __ FromClause
  Import __ ModuleSpecifier
  # NOTE: Added import shorthand
  # NOTE: Not adding $loc to source map here yet because it will point to the start of the identifier
  # the proper place may be to use the From location
  ImpliedImport:i ImportClause:c __:w FromClause:f ->
    // Map implied import location to `from`
    // The pos and length adjustment better match how tsc outputs to include the space before `from` with the `from` token
    i.$loc = {
      pos: f[0].$loc.pos-1,
      length: f[0].$loc.length+1,
    }
    return [i, c, w, f]

ImpliedImport
  "" ->
    return { $loc, token: "import " }

# https://262.ecma-international.org/#prod-ImportClause
ImportClause
  ImportedBinding ( __ Comma __ ( NameSpaceImport / NamedImports ) )?
  NameSpaceImport
  NamedImports

# https://262.ecma-international.org/#prod-NameSpaceImport
NameSpaceImport
  Star __ As NonIdContinue __ ImportedBinding

# https://262.ecma-international.org/#prod-NamedImports
NamedImports
  OpenBrace ImportSpecifier* ( __ Comma )? __ CloseBrace

# https://262.ecma-international.org/#prod-FromClause
FromClause
  From __ ModuleSpecifier

# https://262.ecma-international.org/#prod-ImportSpecifier
ImportSpecifier
  __ ModuleExportName __ As NonIdContinue __ ImportedBinding ObjectPropertyDelimiter
  __ ImportedBinding ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-ModuleExportName
ModuleExportName
  StringLiteral
  IdentifierName

# https://262.ecma-international.org/#prod-ModuleSpecifier
ModuleSpecifier
  UnprocessedModuleSpecifier ->
    // Workaround to fix:
    // https://github.com/microsoft/TypeScript/issues/42151
    // import t.ts
    // "An import path cannot end with a '.ts' extension. Consider importing './t.js' instead."
    const {token} = $1
    // convert .[mc]?ts to .[mc]?js
    return { $loc, token: token.replace(/\.([mc])?ts(['"])$/, ".$1js$2") }

UnprocessedModuleSpecifier
  BasicStringLiteral
  UnquotedSpecifier

UnquotedSpecifier
  # Currently allowing all characters except for whitespace, double quotes, and semi-colon
  # It may make sense to restrict this to only allow characters that are valid in a module specifier
  # Also consider URLs
  /[^;"\s]+/:spec ->
    return { $loc, token: `"${spec}"` }

# https://262.ecma-international.org/#prod-ImportedBinding
ImportedBinding
  BindingIdentifier

# https://262.ecma-international.org/#prod-ExportDeclaration
ExportDeclaration
  Export __ "default" NonIdContinue __ ( HoistableDeclaration / ClassDeclaration / AssignmentExpression )
  Export __ ExportFromClause __ FromClause
  Export __ ( NamedExports / VariableStatement / Declaration )

# https://262.ecma-international.org/#prod-ExportFromClause
ExportFromClause
  Star ( __ As NonIdContinue __ ModuleExportName )?
  NamedExports

# https://262.ecma-international.org/#prod-NamedExports
NamedExports
  OpenBrace ExportSpecifier* (__ Comma )? __ CloseBrace

# https://262.ecma-international.org/#prod-ExportSpecifier
ExportSpecifier
  __ ModuleExportName ( __ As __ ModuleExportName )? ObjectPropertyDelimiter

# https://262.ecma-international.org/#prod-Declaration
Declaration
  HoistableDeclaration
  ClassDeclaration
  LexicalDeclaration
  TypeDeclaration

# https://262.ecma-international.org/#prod-HoistableDeclaration
HoistableDeclaration
  FunctionDeclaration

# https://262.ecma-international.org/#prod-LexicalDeclaration
LexicalDeclaration
  # NOTE: Eliminated left recursion
  LetOrConst __ LexicalBinding ( __ Comma __ LexicalBinding )* -> {
    type: "VariableDeclaration",
    children: $0,
  }
  # NOTE: Added const shorthand
  InsertConst:c ( BindingPattern / BindingIdentifier ) TypeSuffix? __ ConstAssignment:ca AssignmentExpression ->
    // Adjust position to space before assignment to make TypeScript remapping happier
    c.$loc = {
      pos: ca.$loc.pos - 1,
      length: ca.$loc.length + 1,
    }
    return {
      type: "VariableDeclaration",
      children: $0
    }

ConstAssignment
  ":=" ->
    return { $loc, token: "=" }

# https://262.ecma-international.org/#prod-LexicalBinding
LexicalBinding
  BindingPattern TypeSuffix? Initializer
  BindingIdentifier TypeSuffix? Initializer?

# https://262.ecma-international.org/#prod-Initializer
Initializer
  # TODO: Simplify whitespace prefixing (may need to push it down into the literals)
  # Nested blocks will get shadowed if __ is consumed before them because it consumes the indent
  __ Equals AssignmentExpression

# https://262.ecma-international.org/#prod-VariableStatement
VariableStatement
  Var __ VariableDeclarationList -> {
    type: "VariableDeclaration",
    children: $0,
  }

# https://262.ecma-international.org/#prod-VariableDeclarationList
VariableDeclarationList
  VariableDeclaration ( __ Comma __ VariableDeclaration )*

# https://262.ecma-international.org/#prod-VariableDeclaration
VariableDeclaration
  BindingPattern TypeSuffix? Initializer
  BindingIdentifier TypeSuffix? Initializer?

# https://262.ecma-international.org/#prod-NumericLiteral
NumericLiteral
  NumericLiteralKind ->
    return { $loc, token: $1 }

NumericLiteralKind
  DecimalBigIntegerLiteral
  BinaryIntegerLiteral
  OctalIntegerLiteral
  HexLiteral
  DecimalLiteral

# https://262.ecma-international.org/#prod-DecimalBigIntegerLiteral
DecimalBigIntegerLiteral
  /(?:0|[1-9](?:_[0-9]|[0-9])*)n/
  # /[_0-9]*n/

# https://262.ecma-international.org/#prod-DecimalLiteral
DecimalLiteral
  # NOTE: Not matching the dot as part of a number if it is followed by a valid JS identifier so that it will match as a property access
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?=\.(?:\p{ID_Start}|[_$]))/ ) ->
    // Insert an extra dot to make property access work
    return $1 + "."
  $( /(?:0|[1-9](?:_[0-9]|[0-9])*)(?:\.(?:[0-9](?:_[0-9]|[0-9])*))?/ ExponentPart? )
  $( /(?:\.[0-9](?:_[0-9]|[0-9])*)/ ExponentPart? )

ExponentPart
  /(?:[eE][+-]?[0-9]+(?:_[0-9]|[0-9])*)/

# https://262.ecma-international.org/#prod-BinaryIntegerLiteral
BinaryIntegerLiteral
  /0[bB][01](?:[01]|_[01])*n?/

# https://262.ecma-international.org/#prod-OctalIntegerLiteral
OctalIntegerLiteral
  /0[oO][0-7](?:[0-7]|_[0-7])*n?/

# https://262.ecma-international.org/#prod-HexIntegerLiteral
HexLiteral
  /0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_[0-9a-fA-F])*n?/

# https://262.ecma-international.org/#prod-StringLiteral
StringLiteral
  # NOTE: actual CoffeeScript """ string behaviors are pretty weird, this is simplifed
  TripleDoubleQuote ( TripleDoubleStringCharacters / CoffeeStringSubstitution )* TripleDoubleQuote ->
    return module.dedentBlockSubstitutions($0)

  TripleSingleQuote:s TripleSingleStringCharacters:str TripleSingleQuote:e ->
    return [s, module.dedentBlockString(str), e]

  # CoffeeScript Interpolation is enabled when "civet coffee-compat" or "civet coffee-interpolation" directive is present
  CoffeeInterpolatedDoubleQuotedString
  BasicStringLiteral

BasicStringLiteral
  DoubleQuote DoubleStringCharacters:str DoubleQuote ->
    return {
      token: `"${module.modifyString(str.token)}"`,
      $loc,
    }

  SingleQuote SingleStringCharacters:str SingleQuote ->
    return {
      token: `'${module.modifyString(str.token)}'`,
      $loc,
    }

DoubleStringCharacters
  /(?:\\.|[^"])*/ ->
    return { $loc, token: $0 }

SingleStringCharacters
  /(?:\\.|[^'])*/ ->
    return { $loc, token: $0 }

TripleDoubleStringCharacters
  /(?:"(?!"")|#(?!\{)|\\.|[^#"])+/ ->
    return { $loc, token: $0 }

TripleSingleStringCharacters
  /(?:'(?!'')|\\.|[^'])*/ ->
    return { $loc, token: $0 }

CoffeeStringSubstitution
  CoffeeSubstitutionStart Expression __ CloseBrace

CoffeeInterpolatedDoubleQuotedString
  CoffeeInterpolationEnabled DoubleQuote:s ( CoffeeDoubleQuotedStringCharacters / CoffeeStringSubstitution )*:parts DoubleQuote:e ->
    const noInterpolations = parts.length === 1 && parts[0].token != null
    if (noInterpolations) {
      return {
        token: `"${module.modifyString(parts[0].token)}"`,
        $loc,
      }
    }

    parts.forEach((part) => {
      // Is a string
      if(part.token) {
        // Escape '${' and '`'
        const str = part.token.replace(/(`|\$\{)/g, "\\$1")
        // Escape non-continuation newlines
        part.token = module.modifyString(str)
      }
    })

    // Convert to backtick enclosed string
    s.token = e.token = "`"

    return [s, parts, e]

CoffeeDoubleQuotedStringCharacters
  /(?:\\.|#(?!\{)|[^"#])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#prod-RegularExpressionLiteral
RegularExpressionLiteral
  $("/" RegularExpressionBody "/" RegularExpressionFlags) ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-RegularExpressionBody
# NOTE: Simplified a little from the spec, ignoring <PS>, <LS>
RegularExpressionBody
  ![*\/\r\n] RegExpCharacter*

RegExpCharacter
  /(?:\\.|[^\/\r\n])+/

# https://262.ecma-international.org/#prod-RegularExpressionFlags
RegularExpressionFlags
  /(?:\p{ID_Continue}|[\u200C\u200D$])*/

# https://262.ecma-international.org/#prod-TemplateLiteral
# NOTE: Simplified template grammar
TemplateLiteral
  TripleTick ( TemplateBlockCharacters / TemplateSubstitution )* TripleTick ->
    return module.dedentBlockSubstitutions($0)

  Backtick ( TemplateCharacters / TemplateSubstitution )* Backtick

# NOTE: Simplified grammar
TemplateSubstitution
  SubstitutionStart Expression __ CloseBrace

# https://262.ecma-international.org/#prod-TemplateCharacter
TemplateCharacters
  /(?:\$(?!\{)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

TemplateBlockCharacters
  /(?:\$(?!\{)|`(?!``)|\\.|[^$`])+/ ->
    return { $loc, token: $0 }

# https://262.ecma-international.org/#sec-comments
ReservedWord
  CoffeeBooleansEnabled /(?:on|off|yes|no)(?!\p{ID_Continue})/
  CoffeeIsntEnabled /(?:isnt)(?!\p{ID_Continue})/
  /(?:and|as|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|import|in|instanceof|interface|is|loop|new|null|or|return|static|super|switch|this|throw|true|try|typeof|unless|until|var|void|while|with|yield)(?!\p{ID_Continue})/

# https://262.ecma-international.org/#sec-comments
Comment
  MultiLineComment
  SingleLineComment

SingleLineComment
  /\/\/[^\r\n]*/ ->
    return { $loc, token: $0 }
  CoffeeCommentEnabled CoffeeSingleLineComment

# https://262.ecma-international.org/#prod-MultiLineComment
MultiLineComment
  JSMultiLineComment
  # NOTE: Added CoffeeScript style ### multiline comments
  CoffeeMultiLineComment

JSMultiLineComment
  $( "/*" (!"*/" . )* "*/" ) ->
    return { $loc, token: $1 }

CoffeeSingleLineComment
  # NOTE: CoffeeScript style single line comments
  /#([^\r\n]*)/ ->
    return { $loc, token: `//${$1}` }

CoffeeMultiLineComment
  "###" $( !("###" / "*/") . )* "###" ->
    return { $loc, token: `/*${$2}*/` }

# InlineComment is a multi-line comment with no line separators
InlineComment
  $( "/*" $(!"*/" [^\r\n] )* "*/" ) ->
    return { $loc, token: $1 }

RestOfLine
  (NonNewlineWhitespace / SingleLineComment / MultiLineComment)* EOL

TrailingComment
  (NonNewlineWhitespace / InlineComment / SingleLineComment)

# Non-newline "white space" (includes comments)
# TODO: JS counts line terminators that appear in multi-line comments. For example "return /*\n*/5" is different than "return /**/ 5" because of the newline within the comment
# NOTE: Maybe Comment should only be single line comments here?
_
  (NonNewlineWhitespace / Comment)+

NonNewlineWhitespace
  [ \t]+ ->
    return { $loc, token: $0 }

# Optional whitespace including newlines and comments
__
  (Whitespace / Comment)*

Whitespace
  [\s]+ ->
    return { $loc, token: $0 }

StatementDelimiter
  TrailingComment* Semicolon TrailingComment*
  &EOS

NonIdContinue
  /(?!\p{ID_Continue})/

Loc
  "" ->
    return { $loc, token: "" }

## Tokens

As
  "as" NonIdContinue ->
    return { $loc, token: $1 }

Async
  "async" ->
    return { $loc, token: $1 }

Await
  "await" NonIdContinue ->
    return { $loc, token: $1 }

Backtick
  "`" ->
    return { $loc, token: $1 }

Case
  "case" NonIdContinue ->
    return { $loc, token: $1 }

Catch
  "catch" ->
    return { $loc, token: $1 }

Class
  "class" ->
    return { $loc, token: $1 }

CloseBrace
  "}" ->
    return { $loc, token: $1 }

CloseBracket
  "]" ->
    return { $loc, token: $1 }

CloseParen
  ")" ->
    return { $loc, token: $1 }

CoffeeSubstitutionStart
  "#{" ->
    return { $loc, token: "${" }

Colon
  ":" ->
    return { $loc, token: $1 }

Comma
  "," ->
    return { $loc, token: $1 }

ConstructorShorthand
  "@" ->
    return { $loc, token: "constructor" }

Default
  "default" NonIdContinue ->
    return { $loc, token: $1 }

Delete
  "delete" NonIdContinue ->
    return { $loc, token: $1 }

Do
  "do" NonIdContinue ->
    return { $loc, token: $1 }

Dot
  "." ->
    return { $loc, token: $1 }

DotDot
  ".." ->
    return { $loc, token: $1 }

DotDotDot
  "..." ->
    return { $loc, token: $1 }

DoubleQuote
  "\"" ->
    return { $loc, token: $1 }

Else
  "else" ->
    return { $loc, token: $1 }

Equals
  "=" ->
    return { $loc, token: $1 }

Export
  "export" NonIdContinue ->
    return { $loc, token: $1 }

For
  "for" NonIdContinue ->
    return { $loc, token: $1 }

From
  "from" NonIdContinue ->
    return { $loc, token: $1 }

Function
  "function" ->
    return { $loc, token: $1 }

GetOrSet
  ( "get" / "set" ) NonIdContinue ->
    return { $loc, token: $1 }

If
  "if" ->
    return { $loc, token: $1 }

Import
  # NOTE: this is a hack so import.meta will parse correctly
  "import" &/\s/ ->
    return { $loc, token: $1 }

In
  "in" ->
    return { $loc, token: $1 }

# https://262.ecma-international.org/#prod-LetOrConst
LetOrConst
  "let" / "const" ->
    return { $loc, token: $1 }

Loop
  # NOTE: loop becomes while
  "loop" NonIdContinue ->
    return { $loc, token: "while(true)" }

New
  "new" ->
    return { $loc, token: $1 }

Of
  "of" ->
    return { $loc, token: $1 }

OpenBrace
  "{" ->
    return { $loc, token: $1 }

OpenBracket
  "[" ->
    return { $loc, token: $1 }

OpenParen
  "(" ->
    return { $loc, token: $1 }

QuestionMark
  "?" ->
    return { $loc, token: $1 }

Return
  "return" NonIdContinue ->
    return { $loc, token: $1 }

Semicolon
  ";" ->
    return { $loc, token: $1 }

SingleQuote
  "'" ->
    return { $loc, token: $1 }

Star
  "*" ->
    return { $loc, token: $1 }

Static
  "static" ->
    return { $loc, token: $1 }
  # NOTE: In ClassElements @ is a shorthand for 'static'
  # NOTE: added negative assertion to prevent overlapping constructor shorthand
  "@" !"(" ->
    return { $loc, token: "static " }

SubstitutionStart
  "${" ->
    return { $loc, token: $1 }

Switch
  "switch" NonIdContinue ->
    return { $loc, token: $1 }

Target
  "target" ->
    return { $loc, token: $1 }

Throw
  "throw" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: These become a single backtick
TripleDoubleQuote
  "\"\"\"" ->
    return { $loc, token: "`" }

# NOTE: These become a single backtick
TripleSingleQuote
  "'''" ->
    return { $loc, token: "`" }

TripleTick
  "```" ->
    return { $loc, token: "`" }

Try
  "try" ->
    return { $loc, token: $1 }

Typeof
  "typeof" NonIdContinue ->
    return { $loc, token: $1 }

Unless
  "unless" ->
    return { $loc, token: $1 }

Until
  "until" NonIdContinue ->
    return { $loc, token: $1 }

Var
  "var" ->
    return { $loc, token: $1 }

Void
  "void" NonIdContinue ->
    return { $loc, token: $1 }

# NOTE: When maps to 'case'
When
  "when" NonIdContinue ->
    return { $loc, token: "case" }

While
  "while" NonIdContinue ->
    return { $loc, token: $1 }

Yield
  "yield" NonIdContinue ->
    return { $loc, token: $1 }

## JSX

# https://facebook.github.io/jsx/#prod-JSXElement
JSXElement
  JSXSelfClosingElement
  JSXOpeningElement JSXChildren* __ JSXClosingElement ->
    // Check that tags match
    if ($1[1] !== $4[2]) {
      throw new Error(`mismatched closing tags at ${JSON.stringify($loc)}`)
    }
    return $0

# https://facebook.github.io/jsx/#prod-JSXSelfClosingElement
JSXSelfClosingElement
  "<" $JSXElementName JSXAttributes? __ "/>"

# https://facebook.github.io/jsx/#prod-JSXOpeningElement
JSXOpeningElement
  "<" $JSXElementName JSXAttributes? __ ">"

# https://facebook.github.io/jsx/#prod-JSXClosingElement
JSXClosingElement
  "</" __ $JSXElementName __ ">"

# https://facebook.github.io/jsx/#prod-JSXFragment
JSXFragment
  "<>" JSXChildren? "</>"

# https://facebook.github.io/jsx/#prod-JSXElementName
JSXElementName
  # Merged in https://facebook.github.io/jsx/#prod-JSXNamespacedName
  # Merged in https://facebook.github.io/jsx/#prod-JSXMemberExpression
  JSXIdentifierName ( (Colon JSXIdentifierName) / ( Dot JSXIdentifierName )* )

# NOTE: Like IdentifierName but includes hyphens after start
# NOTE: Combined from recursive https://facebook.github.io/jsx/#prod-JSXIdentifier definition
JSXIdentifierName
  /(?:\p{ID_Start}|[_$])(?:\p{ID_Continue}|[\u200C\u200D$-])*/

# https://facebook.github.io/jsx/#prod-JSXAttributes
JSXAttributes
  ( __ JSXAttribute )*

# NOTE: Merged SpreadAttribute and Attribute
JSXAttribute
  # https://facebook.github.io/jsx/#prod-JSXSpreadAttribute
  OpenBrace __ DotDotDot AssignmentExpression __ CloseBrace

  # https://facebook.github.io/jsx/#prod-JSXAttribute
  JSXAttributeName JSXAttributeInitializer?

# https://facebook.github.io/jsx/#prod-JSXAttributeName
JSXAttributeName
  # NOTE: Merged JSXIdentifier and JSXNamespacedName
  JSXIdentifierName ( Colon JSXIdentifierName )?

# https://facebook.github.io/jsx/#prod-JSXAttributeInitializer
JSXAttributeInitializer
  __ Equals __ JSXAttributeValue

# https://facebook.github.io/jsx/#prod-JSXAttributeValue
JSXAttributeValue
  # https://facebook.github.io/jsx/#prod-JSXDoubleStringCharacters
  /"[^"]*"/
  # https://facebook.github.io/jsx/#prod-JSXSingleStringCharacters
  /'[^']*'/
  OpenBrace AssignmentExpression __ CloseBrace
  JSXElement
  JSXFragment

# https://facebook.github.io/jsx/#prod-JSXChildren
JSXChildren
  ( __ JSXChild )*

# https://facebook.github.io/jsx/#prod-JSXChild
JSXChild
  JSXText
  JSXElement
  JSXFragment
  OpenBrace JSXChildExpression? __ CloseBrace

# https://facebook.github.io/jsx/#prod-JSXText
JSXText
  # NOTE: not currently excluding https://facebook.github.io/jsx/#prod-HTMLCharacterReference
  [^{}<>]+

# https://facebook.github.io/jsx/#prod-JSXChildExpression
JSXChildExpression
  __ ( DotDotDot __ )? AssignmentExpression

## Type Stuff

TypeDeclaration
  (TypeDeclarationModifier TrailingComment*)* TypeDeclarationRest -> { ts: true, children: $0 }

TypeDeclarationModifier
  "declare" NonIdContinue
  Export

TypeDeclarationRest
  TypeKeyword TrailingComment* IdentifierName TypeParameters? __ Equals __ Type
  Interface   TrailingComment* IdentifierName TypeParameters? InterfaceBlock
  Namespace   TrailingComment* IdentifierName NamespaceBlock
  FunctionSignature

TypeKeyword
  "type" NonIdContinue

Interface
  "interface" NonIdContinue

Namespace
  "namespace" NonIdContinue

InterfaceBlock
  __ OpenBrace EOS NestedInterfaceProperties __ CloseBrace
  __ OpenBrace ( __ InterfaceProperty )* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedInterfaceProperties InsertNewline InsertIndent InsertCloseBrace

NestedInterfaceProperties
  PushIndent NestedInterfaceProperty*:props PopIndent ->
    if (props.length) return props
    return $skip

NestedInterfaceProperty
  Nested InterfaceProperty

InterfaceProperty
  ( TypeIndexSignature / PropertyName ) TypeSuffix InterfacePropertyDelimiter
  NonEmptyParameters TypeSuffix InterfacePropertyDelimiter
  MethodSignature InterfacePropertyDelimiter

InterfacePropertyDelimiter
  _* ( Semicolon / Comma )
  &( __ CloseBrace )
  &EOS

NamespaceBlock
  __ OpenBrace EOS NestedTypeDeclarations __ CloseBrace
  __ OpenBrace ( __ TypeDeclaration InterfacePropertyDelimiter)* __ CloseBrace
  # NOTE: Added indentation based implied braces
  InsertOpenBrace EOS NestedTypeDeclarations InsertNewline InsertIndent InsertCloseBrace

NestedTypeDeclarations
  PushIndent NestedTypeDeclaration*:decs PopIndent ->
    if (decs.length) return decs
    return $skip

NestedTypeDeclaration
  Nested TypeDeclaration InterfacePropertyDelimiter

TypeIndexSignature
  ( [+-]? "readonly" __ )? OpenBracket TypeIndex CloseBracket ( __ [+-] QuestionMark )?

TypeIndex
  __ Identifier TypeSuffix
  __ PropertyName __ In Type ( __ As Type )?

TypeSuffix
  QuestionMark? __ Colon Type -> {
    type: "TypeSuffix",
    ts: true,
    children: $0
  }

ReturnTypeSuffix
  __ Colon ( __ "asserts" NonIdContinue )? TypePredicate ->
    if (!$3) $0.splice(2, 1)
    if ($1.length === 0) $0.shift()

    return {
      type: "ReturnTypeAnnotation",
      children: $0,
      ts: true,
    }

TypePredicate
  Type ( __ "is" NonIdContinue Type )? ->
    if (!$2) return $1
    return $0

Type
  TypeConditional

TypeBinary
  TypeUnary (__ TypeBinaryOp __ TypeUnary)* ->
    if ($2.length) return $0
    return $1

TypeUnary
  ( __ TypeUnaryOp NonIdContinue )* TypePrimary TypeUnarySuffix* ->
    if (!$3.length) $0.pop()
    if (!$1.length) $0.shift()
    return $0

TypeUnarySuffix
  TypeIndexedAccess
  QuestionMark

TypeUnaryOp
  "keyof"
  "typeof"
  "infer"

TypeIndexedAccess
  __ OpenBracket Type? __ CloseBracket

TypePrimary
  InterfaceBlock
  __ OpenParen Type __ CloseParen
  __ TypeTuple
  _* FunctionType
  _* TypeLiteral
  _* IdentifierName (Dot IdentifierName)* TypeArguments?

TypeTuple
  OpenBracket NestedTypeList __ CloseBracket
  OpenBracket TypeList? __ CloseBracket

TypeList
  Type (__ Comma Type)*

NestedTypeList
  PushIndent NestedType*:types PopIndent ->
    if (types.length)
      return types
    return $skip

NestedType
  Nested Type ArrayElementDelimiter

TypeConditional
  TypeBinary ( __ "extends" Type ( __ QuestionMark Type __ Colon Type )? )? ->
    if ($2) return $0
    return $1

TypeLiteral
  Literal
  "void" ->
    return { $loc, token: "void" }
  "[]" ->
    return { $loc, token: "[]" }

TypeBinaryOp
  "|" ->
    return { $loc, token: "|" }
  "&" ->
    return { $loc, token: "&" }

FunctionType
  Parameters __ "=>" Type

TypeArguments
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">"

TypeParameters
  __ "<" __ Type (__ Comma __ Type)* (__ Comma)? __ ">" ->
    return { ts: true, children: $0 }

TypeParameter
  __ Identifier TypeConstraint? TypeParameterDelimiter

TypeConstraint
  __ "extends" Type

TypeParameterDelimiter
  _* Comma
   # NOTE: Don't insert comma before inline closing angle bracket
  &( _* ">" )
  # NOTE: Do insert comma before closing angle bracket on following line
  &( __ ">" ) ->
    return { $loc, token: "," }
  &EOS ->
    return { $loc, token: "," }

## Utility

Shebang
  /#![^\r\n]*/ EOL

CivetPrologue
  [\t ]* DoubleQuote CivetPrologueContent:content DoubleQuote $StatementDelimiter EOS -> content
  [\t ]* SingleQuote CivetPrologueContent:content SingleQuote $StatementDelimiter EOS -> content

CivetPrologueContent
  "civet" CivetOption*:options [\s]* ->
    return {
      type: "CivetPrologue",
      children: [],
      config: Object.fromEntries(options),
    }

CivetOption
  /\s+([+-]?)([a-zA-Z0-9-]+)/ ->
    // Normalize option names to camelCase
    const optionName = $2.replace(/-+([a-z]?)/g, (_, l) => {
      if (l) return l.toUpperCase()
      return ""
    })
    // - is disabled, + is enabled, no prefix is enabled
    const value = ($1 === "-") ? false : true

    return [optionName, value]

UnknownPrologue
  # NOTE: $ is to keep source verbatim and not insert a semicolon if one was omitted
  # Can't use $EOS because it will prevent re-writing of coffee style comments
  [\t ]* BasicStringLiteral:s $StatementDelimiter EOS

DirectivePrologue
  CivetPrologue
  UnknownPrologue

EOS
  RestOfLine+

# End of line, including EOF
EOL
  /\r\n|\n|\r|$/ ->
    return { $loc, token: $0 }

Debugger
  "" ->
    debugger

# Insertions

InsertOpenParen
  "" ->
    return { $loc, token: "(" }

InsertCloseParen
  "" ->
    return { $loc, token: ")" }

InsertOpenBrace
  # NOTE: Includes a preceding space
  "" ->
    return [{ $loc, token: " " }, { $loc, token: "{" } ]

InsertCloseBrace
  "" ->
    return { $loc, token: "}" }

InsertConst
  # NOTE: Includes a trailing space
  "" ->
    return { $loc, token: "const " }

InsertReadonly
  # NOTE: Includes a trailing space
  "" ->
    return { ts: true, children: [ { $loc, token: "readonly " } ] }

InsertNewline
  "" ->
    return "\n"

InsertIndent
  "" ->
    return "".padStart(module.currentIndent * 2)

InsertSpace
  "" ->
    return { $loc, token: " " }

InsertDot
  "" ->
    return { $loc, token: "." }

InsertBreak
  "" ->
    return { $loc, token: ";break;" }

CoffeeCommentEnabled
  "" ->
    if(module.config.coffeeComment) return
    return $skip

CoffeeBooleansEnabled
  "" ->
    if(module.config.coffeeBooleans) return
    return $skip

CoffeeInterpolationEnabled
  "" ->
    if(module.config.coffeeInterpolation) return
    return $skip

CoffeeIsntEnabled
  "" ->
    if(module.config.coffeeIsnt) return
    return $skip

# Reset module level data
Reset
  "" ->
    // Storage for PushIndent/PopIndent
    module.currentIndent = 0
    module.indentLevels = [0]
    module.verbose = false
    module.config = {
      autoVar: false,
      coffeeBooleans: false,
      coffeeComment: false,
      coffeeEq: false,
      coffeeInterpolation: false,
      coffeeIsnt: false,
      implicitReturns: true,
    }

    // Expand setting coffeeCompat to the individual options
    Object.defineProperty(module.config, "coffeeCompat", {
      set(b) {
        if (b) {
          this.autoVar = true
          this.coffeeBooleans = true
          this.coffeeComment = true
          this.coffeeEq = true
          this.coffeeInterpolation = true
          this.coffeeIsnt = true
        } else {
          this.autoVar = false
          this.coffeeBooleans = false
          this.coffeeComment = false
          this.coffeeEq = false
          this.coffeeInterpolation = false
          this.coffeeIsnt = false
        }
      }
    })

    // TODO: this is only here because directive prologues depend on it
    // eventually all these `module.*` variables should be handled better in Hera
    // Adjust a parsed string by escaping newlines
    module.modifyString = function(str) {
      // Replace non-escaped newlines with escaped newlines
      // taking into account the possibility of a preceding escaped backslash
      return str.replace(/(?<!\\)(\\\\)*\n/g, '$1\\n')
    }

Init
  Shebang? DirectivePrologue*:directives "" ->
    directives.forEach((directive) => {
      if (directive.type === "CivetPrologue") {
        Object.assign(module.config, directive.config)
      }
    })

    // [indent, statement, semicolon]
    function insertReturn(node) {
      if (!node) return
      // TODO: unify this with the `exp` switch
      switch (node.type) {
        case "AssignmentExpression":
          node.children.unshift("return ")
          return
        case "Identifier":
          // TODO: It would be better to wrap/insert a node rather than modify the token
          node.token = "return " + node.token
          return
        case "BlockStatement":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "CaseBlock":
          node.clauses.forEach((clause) => {
            insertReturn(clause)
          })
          return
        case "CaseClause":
          // Don't adjust case clauses
          return
        case "WhenClause":
          // Remove inserted `break;`
          node.children.pop()
          insertReturn(node.expressions[node.expressions.length - 1])
          return
        case "DefaultClause":
          insertReturn(node.expressions[node.expressions.length - 1])
          return
      }
      if (!Array.isArray(node)) return

      const [, exp] = node
      let indent = node[0]
      // Hacky way to get the indent of the last expression
      if (Array.isArray(indent)) indent = indent[indent.length - 1]
      if (!exp) return

      switch (exp.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "EmptyStatement":
        case "IterationStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "VariableDeclaration":
          return
        case "BlockStatement":
          insertReturn(exp.expressions[exp.expressions.length - 1])
          return
        case "IfStatement":
          // if block
          insertReturn(exp.children[2])
          // else block
          if (exp.children[3]) insertReturn(exp.children[3][2])
          // Add explicit return after if block if no else block
          else exp.children.push(["\n", indent, "return"])
          return
        case "SwitchStatement":
          // insert a return in each case block
          insertReturn(exp.children[2])
          return
        case "TryStatement":
          // try block
          insertReturn(exp.children[1])
          // catch block
          insertReturn(exp.children[2][3])
          // NOTE: do not insert a return in the finally block
          return
      }

      // Insert return before expression
      node.splice(1, 0, "return ")
    }

    module.addImplicitReturns = function(block) {
      insertReturn(block)

      return block
    }

    module.isWhitespaceOrEmpty = function(node) {
      if (!node) return true
      if (!node.length) return true
      if (typeof node === "string") return node.match(/^\s*$/)
      if (Array.isArray(node)) return node.every(module.isWhitespaceOrEmpty)
    }

    /**
    * binops is an array of [__, op, __, exp] tuples
    * first is an expression
    */
    module.expandChainedComparisons = function([first, binops]) {
      // TODO: add refs to ensure middle expressions are evaluated only once

      // all relational operators could be chained in theory, including in and instanceof
      const relationalOps = ["==", "===", "!=", "!==", "<", "<=", ">", ">=", "in", "instanceof"]

      // short circuit/bitwise ops have lower precedence than comparison ops
      // so we only need to look for chains in the sections between them
      const lowerPrecedenceOps = ["??", "&&", "||", "&", "|", "^"]

      // shift/arithmetic ops have higher precedence, they will bind to expressions inside the chains
      // const higherPrecedenceOps = ["<<", ">>", ">>>", "+", "-", "*", "**", "/", "%"]

      let results = []

      let i = 0
      let l = binops.length

      let start = 0
      // indexes of chainable ops
      let chains = []
      while (i < l) {
        const [, op] = binops[i]

        if (relationalOps.includes(op.token)) {
          chains.push(i)
        } else if (lowerPrecedenceOps.includes(op.token)) {
          // end of the chain
          processChains()
          first = []
        }

        i++
      }

      processChains()

      return results

      function processChains() {
        if (chains.length > 1) {
          chains.forEach((index, k) => {
            if (k > 0) {
              results.push(" && ")
            }
            const [pre, op, post, exp] = binops[index]

            let endIndex
            if (k < chains.length - 1) {
              endIndex = chains[k + 1]
            } else {
              endIndex = i + 1
            }

            results = results.concat(first, ...binops.slice(start, endIndex))
            first = [exp].concat(binops.slice(index + 1, endIndex))
            start = endIndex
          })
        } else {
          // Advance start if there was no chain
          results = results.concat(first, ...binops.slice(start, i + 1))
          start = i + 1
        }

        chains.length = 0
      }
    }

    // Return an array of Rule names that correspond to the current call stack
    module.parsePosition = function() {
      let s = Error().stack.split(/\n    at /)
      s.shift()
      s = s.filter((e) => !e.match(/^eval/)).map((e) => e.split(' ')[0])
      s = s.slice(1, s.indexOf('Program') + 1)

      return s
    }

    module.prune = function(node) {
      if(node === null || node === undefined) return
      if(node.length === 0) return

      if (Array.isArray(node)) {
        const a = node
        .map((n) => module.prune(n))
        .filter((n) => !!n)

        if(a.length > 1)  return a
        if(a.length === 1) return a[0]
        return
      }

      if(node.children != null) {
        node.children = module.prune(node.children)
        return node
      }

      return node
    }

    // Trims the first single space from the spacing array if present
    // maintains $loc for source maps
    module.insertTrimmingSpace = function(spacing, c) {
      let target = spacing

      while(Array.isArray(target)) {
        target = target[0]
      }

      if (target.token) {
        target.token = target.token.replace(/^ ?/, c)
      }

      return spacing
    }

    // Split out leading newlines from the first indented line
    const initialSpacingRe = /^(?:\r?\n|\n)*((?:\r?\n|\n)\s+)/

    module.dedentBlockSubstitutions = function($0) {
      const [s, strWithSubstitutions, e] = $0

      if (strWithSubstitutions.length === 0) {
        return $0
      }

      let initialSpacing, i=0, l=strWithSubstitutions.length, results=[s]
      // Get initial spacing from the first string token if it is not a substitution
      const {token} = strWithSubstitutions[0]

      if (token) {
        initialSpacing = token.match(initialSpacingRe)
      } else {
        initialSpacing = false
      }

      while (i < l) {
        let segment = strWithSubstitutions[i]

        if (segment.token) {
          segment = module.dedentBlockString(segment, initialSpacing, false)
          if (i === 0) {
            // Trim leading newline
            segment.token = segment.token.replace(/^(\r?\n|\n)/, "")
          }
          if (i === l - 1) {
            // Trim trailing newline
            segment.token = segment.token.replace(/(\r?\n|\n)[ \t]*$/, "")
          }
          results.push(segment)
        } else {
          results.push(segment)
        }

        i++
      }

      results.push(e)
      return results
    }

    module.dedentBlockString = function({$loc, token: str}, spacing, trim=true) {
      // If string begins with a newline then indentation assume that it should be removed for all lines
      if (spacing == null) spacing = str.match(initialSpacingRe)

      if (spacing) {
        str = str.replaceAll(spacing[1], "\n")
        const l = spacing.length
        $loc.pos += l
        $loc.length -= l
      }

      if (trim) {
        // Remove leading newline
        str = str.replace(/^(\r?\n|\n)/, "")
        // Remove trailing newline
        .replace(/(\r?\n|\n)[ \t]*$/, "")
      }

      // escape backtick, $
      str = str.replace(/(`|\$\{)/g, "\\$1")

      return {
        $loc,
        token: str,
      }
    }

    return $0

# Indentation

# Holds the last indent level in `module.lastIndent`
# Can get weird with backtracking but should work out as long as
# EOS/Nested rules are used carefully and if we only compare to the
# pushed value.
Indent
  ( "  " / "\t" )* ->
    const level = $1.length

    return {
      $loc,
      token: "".padStart(level * 2),
      level
    }

# Tracks current indentation without assuming that it should nest deeper
# Must be matched with PopIndent
TrackIndent
  "" ->
    module.indentLevels.push(module.currentIndent)

Samedent
  EOS? Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (level === currentIndent) {
      return $0
    }
    return $skip

IndentedFurther
  EOS? Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (level > currentIndent) {
      return $0
    }
    return $skip

# Indents one level deeper
# Must be matched with PopIndent
PushIndent
  "" ->
    module.currentIndent++
    if (module.verbose) {
      console.log("pushing indent", module.currentIndent)
    }
    module.indentLevels.push(module.currentIndent)

PopIndent
  "" ->
    if (module.verbose) {
      console.log("popping indent", module.indentLevels[module.indentLevels.length-1], "->", module.indentLevels[module.indentLevels.length-2])
    }
    module.indentLevels.pop()
    module.currentIndent = module.indentLevels[module.indentLevels.length-1]

Nested
  EOS?:eos Indent:indent ->
    const { level } = indent
    const currentIndent = module.indentLevels[module.indentLevels.length-1]
    if (module.verbose) {
      console.log("global indent", module.currentIndent)
      console.log("Indented", level, currentIndent)
    }
    if (level !== currentIndent) {
      if (module.verbose) {
        console.log("skipped nested")
      }
      return $skip
    }
    return $0
