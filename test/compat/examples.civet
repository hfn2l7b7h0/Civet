{testCase} from ../helper.civet

describe "example code", ->
  testCase """
    lexer.coffee:166
    ---
    "civet coffeeCompat"
    if id is 'do' and regExSuper = /^(\\s*super)(?!\\(\\))/.exec @chunk[3...]
      @token 'SUPER', 'super'
    ---
    var regExSuper
    if (id === 'do' && (regExSuper = /^(\\s*super)(?!\\(\\))/.exec(this.chunk.slice(3)))) {
      this.token('SUPER', 'super')
    }
  """

  testCase """
    lexer.coffee:113
    ---
    code = code
      .replace /\\r/g, (match, offset) =>
        @locationDataCompensations[thusFar + offset] = 1
        ''
      .replace TRAILING_SPACES, ''
    ---
    code = code
      .replace(/\\r/g, (match, offset) => {
        this.locationDataCompensations[thusFar + offset] = 1
        return ''
    })
      .replace(TRAILING_SPACES, '')
  """

  testCase """
    lexer.coffee:180
    ---
    "civet coffeeCompat"
    tag =
      if colon or prev? and
         (prev[0] in ['.', '?.', '::', '?::'] or
         not prev.spaced and prev[0] is '@')
        'PROPERTY'
      else
        'IDENTIFIER'
    ---
    var tag
    const indexOf: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    tag =
      (colon || prev != null &&
         (indexOf.call(['.', '?.', '::', '?::'], prev[0]) >= 0 ||
         !prev.spaced && prev[0] === '@'))?
        'PROPERTY'
      :
        'IDENTIFIER'
  """

  testCase """
    grammar.coffee
    ---
      Identifier: [
        o 'IDENTIFIER',                             -> new IdentifierLiteral $1
        o 'JSX_TAG',                                -> new JSXTag $1.toString(),
                                                        tagNameLocationData:                  $1.tagNameToken[2]
                                                        closingTagOpeningBracketLocationData: $1.closingTagOpeningBracketToken?[2]
                                                        closingTagSlashLocationData:          $1.closingTagSlashToken?[2]
                                                        closingTagNameLocationData:           $1.closingTagNameToken?[2]
                                                        closingTagClosingBracketLocationData: $1.closingTagClosingBracketToken?[2]
      ]
    ---
      {Identifier: [
        o('IDENTIFIER',                             function() { return new IdentifierLiteral($1) }),
        o('JSX_TAG',                                function() { return new JSXTag($1.toString(), {
                                                        tagNameLocationData:                  $1.tagNameToken[2],
                                                        closingTagOpeningBracketLocationData: $1.closingTagOpeningBracketToken?.[2],
                                                        closingTagSlashLocationData:          $1.closingTagSlashToken?.[2],
                                                        closingTagNameLocationData:           $1.closingTagNameToken?.[2],
                                                        closingTagClosingBracketLocationData: $1.closingTagClosingBracketToken?.[2],
        }) })
      ]}
  """

  testCase """
    lexer.coffee 983
    ---
    "civet coffeeCompat"
    addTokenData token, initialChunk: yes if i is 0
    ---
    if (i === 0) { addTokenData(token, {initialChunk: true}) }
  """

  describe.skip "", ->
    testCase """
      nodes.coffee 1027
      ---
      "civet coffeeCompat"
      val = if @fromSourceString
        val
      else if heredoc
        indentRegex = /// \\n\#{@indent} ///g if @indent
      ---
      var indentRegex, val
      val =
        if (!this.fromSourceString) {
          val


    """

  describe.skip "TODO", ->
    testCase """
      lexer.coffee for expressions inside function arguments
      ---
      "civet coffeeCompat"
      commentTokens = flatten(
        for commentOpts in comments
          @commentToken commentOpts.comment, Object.assign commentOpts, heregex: yes, returnCommentTokens: yes
      )
      ---
    """
