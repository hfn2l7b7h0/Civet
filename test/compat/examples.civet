{testCase} from ../helper.civet

describe "example code", ->
  testCase """
    lexer.coffee:166
    ---
    "civet coffeeCompat"
    if id is 'do' and regExSuper = /^(\\s*super)(?!\\(\\))/.exec @chunk[3...]
      @token 'SUPER', 'super'
    ---
    var regExSuper
    if (id === 'do' && (regExSuper = /^(\\s*super)(?!\\(\\))/.exec(this.chunk.slice(3)))) {
      this.token('SUPER', 'super')
    }
  """

  testCase """
    lexer.coffee:113
    ---
    code = code
      .replace /\\r/g, (match, offset) =>
        @locationDataCompensations[thusFar + offset] = 1
        ''
      .replace TRAILING_SPACES, ''
    ---
    code = code
      .replace(/\\r/g, (match, offset) => {
        this.locationDataCompensations[thusFar + offset] = 1
        return ''
    })
      .replace(TRAILING_SPACES, '')
  """

  testCase """
    lexer.coffee:180
    ---
    "civet coffeeCompat"
    tag =
      if colon or prev? and
         (prev[0] in ['.', '?.', '::', '?::'] or
         not prev.spaced and prev[0] is '@')
        'PROPERTY'
      else
        'IDENTIFIER'
    ---
    var tag
    const indexOf: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    tag =
      (colon || prev != null &&
         (indexOf.call(['.', '?.', '::', '?::'], prev[0]) >= 0 ||
         !prev.spaced && prev[0] === '@'))?
        'PROPERTY'
      :
        'IDENTIFIER'
  """

  testCase """
    grammar.coffee
    ---
      Identifier: [
        o 'IDENTIFIER',                             -> new IdentifierLiteral $1
        o 'JSX_TAG',                                -> new JSXTag $1.toString(),
                                                        tagNameLocationData:                  $1.tagNameToken[2]
                                                        closingTagOpeningBracketLocationData: $1.closingTagOpeningBracketToken?[2]
                                                        closingTagSlashLocationData:          $1.closingTagSlashToken?[2]
                                                        closingTagNameLocationData:           $1.closingTagNameToken?[2]
                                                        closingTagClosingBracketLocationData: $1.closingTagClosingBracketToken?[2]
      ]
    ---
      {Identifier: [
        o('IDENTIFIER',                             function() { return new IdentifierLiteral($1) }),
        o('JSX_TAG',                                function() { return new JSXTag($1.toString(), {
                                                        tagNameLocationData:                  $1.tagNameToken[2],
                                                        closingTagOpeningBracketLocationData: $1.closingTagOpeningBracketToken?.[2],
                                                        closingTagSlashLocationData:          $1.closingTagSlashToken?.[2],
                                                        closingTagNameLocationData:           $1.closingTagNameToken?.[2],
                                                        closingTagClosingBracketLocationData: $1.closingTagClosingBracketToken?.[2],
        }) })
      ]}
  """

  testCase """
    lexer.coffee 983
    ---
    "civet coffeeCompat"
    addTokenData token, initialChunk: yes if i is 0
    ---
    if (i === 0) { addTokenData(token, {initialChunk: true}) }
  """

  testCase """
    nodes.coffee 1027
    ---
    "civet coffeeCompat"
    val =
      unless @fromSourceString
        val
      else if heredoc
        indentRegex = /// \\n\#{@indent} ///g if @indent

        val = val.replace indentRegex, '\\n' if indentRegex
        val = val.replace LEADING_BLANK_LINE,  '' if @initialChunk
        val = val.replace TRAILING_BLANK_LINE, '' if @finalChunk
        val
      else
        val.replace SIMPLE_STRING_OMIT, (match, offset) =>
          if (@initialChunk and offset is 0) or
              (@finalChunk and offset + match.length is val.length)
            ''
          else
            ' '
    ---
    var val, indentRegex
    val =
      (!(this.fromSourceString))?
        val
      : (heredoc)?(
        (this.indent)?indentRegex = RegExp(`\\\\n${this.indent}`, "g"):void 0,

        (indentRegex)?val = val.replace(indentRegex, '\\n'):void 0,
        (this.initialChunk)?val = val.replace(LEADING_BLANK_LINE,  ''):void 0,
        (this.finalChunk)?val = val.replace(TRAILING_BLANK_LINE, ''):void 0,
        val
      )
      :(
        val.replace(SIMPLE_STRING_OMIT, (match, offset) => {
          if ((this.initialChunk && offset === 0) ||
              (this.finalChunk && offset + match.length === val.length)) {
            return ''
          }
          else {
            return ' '
          }
        })
      )
  """

  testCase """
    nodes.coffee 1123
    ---
    astProperties: (o) ->
      [, pattern] = @REGEX_REGEX.exec @value
      return {
        value: undefined
        pattern, @flags, @delimiter
      }
    ---
    {astProperties: function(o) {
      [, pattern] = this.REGEX_REGEX.exec(this.value)
      return {
        value: undefined,
        pattern, flags: this.flags, delimiter: this.delimiter
      }
    }}
  """

  testCase """
    nodes.coffee 1420
    ---
    (thisLiteral = @base) + ThisLiteral
    ---
    (thisLiteral = this.base) + ThisLiteral
  """

  testCase """
    lexer.coffee 146
    ---
    "civet coffeeCompat"
    [prev[0], prev[1]] = ['IDENTIFIER', @value(yes)]
    ---
    [prev[0], prev[1]] = ['IDENTIFIER', this.value(true)]
  """

  describe.skip "TODO", ->
    testCase """
      lexer.coffee for expressions inside function arguments
      ---
      "civet coffeeCompat"
      commentTokens = flatten(
        for commentOpts in comments
          @commentToken commentOpts.comment, Object.assign commentOpts, heregex: yes, returnCommentTokens: yes
      )
      ---
    """
