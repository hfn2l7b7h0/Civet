{testCase} from ./helper.civet

describe "coffee compat", ->
  testCase """
    ==
    ---
    "civet coffee-compat"
    a == b
    ---
    a === b
  """

  testCase """
    !=
    ---
    "civet coffee-compat"
    a != b
    ---
    a !== b
  """

  testCase """
    isnt
    ---
    "civet coffee-compat"
    a isnt b
    ---
    a !== b
  """

  testCase """
    first line comment
    ---
    "civet coffee-compat"
    # first line comment
    ---
    // first line comment
  """

  testCase """
    shebang with directive
    ---
    #! /usr/bin/env coffee
    "civet coffee-compat"
    # comment
    ---
    #! /usr/bin/env coffee
    // comment
  """

  testCase """
    in becomes indexOf
    ---
    "civet coffee-compat"
    a in b
    ---
    const indexOf: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    indexOf.call(b, a) >= 0
  """

  testCase """
    indexOf doesn't collide with other refs
    ---
    "civet coffee-compat"
    import {indexOf} from 'lodash'
    a in b
    ---
    const indexOf1: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    import {indexOf} from 'lodash'
    indexOf1.call(b, a) >= 0
  """

  testCase """
    indexOf precedence
    ---
    "civet coffee-compat"
    a in b or c
    ---
    const indexOf: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    indexOf.call(b, a) >= 0 || c
  """

  testCase """
    indexOf chained comparisons
    ---
    "civet coffee-compat"
    a in b in d
    ---
    const indexOf: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    indexOf.call(b, a) >= 0 && indexOf.call(d, b) >= 0
  """

  testCase """
    indexOf with auto var dec
    ---
    "civet coffee-compat"
    a = 3
    a in b
    ---
    var a
    const indexOf: <T>(this: T[], searchElement: T) => boolean = [].indexOf as any
    a = 3
    indexOf.call(b, a) >= 0
  """

  describe "a of b", ->
    testCase """
      a of b
      ---
      "civet coffee-compat"
      a of b
      ---
      a in b
    """

  describe "Coffee for loops", ->
    testCase """
      for in
      ---
      "civet coffee-compat"
      for a in b
        a.i
      ---
      var a
      for (let i = 0, len = b.length; i < len; i++) {
        a = b[i]
        a.i
      }
    """

    testCase """
      for in i in scope
      ---
      "civet coffee-compat"
      for a in b
        a[i]++
      ---
      var a
      for (let i1 = 0, len = b.length; i1 < len; i1++) {
        a = b[i1]
        a[i]++
      }
    """

    testCase """
      for in range fixed
      ---
      "civet coffee-compat"
      for a in [1..10]
        console.log a
      ---
      var a
      for (let i = a = 1, asc = 1 <= 10; asc ? i <= 10 : i >= 10; a = asc ? ++i : --i) {
        console.log(a)
      }
    """

    testCase """
      for in range variable end
      ---
      "civet coffee-compat"
      for a in [1..b]
        console.log a
      ---
      var a
      for (let i = a = 1, asc = 1 <= b; asc ? i <= b : i >= b; a = asc ? ++i : --i) {
        console.log(a)
      }
    """

    testCase """
      for in range start and end variable
      ---
      "civet coffee-compat"
      for a in [x...y]
        console.log a
      ---
      var a
      for (let i = a = x, asc = x <= y; asc ? i < y : i > y; a = asc ? ++i : --i) {
        console.log(a)
      }
    """

    testCase """
      for in in variable range with literal step
      ---
      "civet coffee-compat"
      for a in [x..y] by 2
        console.log a
      ---
      var a
      for (let i = a = x; 2 !== 0 && (2 > 0 ? i <= y : i >= y); a = i += 2) {
        console.log(a)
      }
    """

    testCase """
      for in range start and end variable with step
      ---
      "civet coffee-compat"
      for a in [x...y] by z
        console.log a
      ---
      var a
      for (let i = a = x, step = z; step !== 0 && (step > 0 ? i < y : i > y); a = i += step) {
        console.log(a)
      }
    """

    testCase """
      for in expression
      ---
      "civet coffee-compat"
      for a in b.x
        a.x
      ---
      var a
      for (let ref = b.x, i = 0, len = ref.length; i < len; i++) {
        a = ref[i]
        a.x
      }
    """

    testCase """
      for in when
      ---
      "civet coffee-compat"
      for a in b when a > 0
        a.x
      ---
      var a
      for (let i = 0, len = b.length; i < len; i++) {
        a = b[i]
        if (!(a > 0)) continue
        a.x
      }
    """

    testCase """
      multiple for in
      ---
      "civet coffee-compat"
      for a in b
        a.x

      for c in d
        c.x
      ---
      var a, c
      for (let i = 0, len = b.length; i < len; i++) {
        a = b[i]
        a.x
      }

      for (let i = 0, len = d.length; i < len; i++) {
        c = d[i]
        c.x
      }
    """

    testCase """
      nested for in loop
      ---
      "civet coffee-compat"
      for a in b
        for c in d
          a.x
      ---
      var a, c
      for (let i1 = 0, len1 = b.length; i1 < len1; i1++) {
        a = b[i1]
        for (let i = 0, len = d.length; i < len; i++) {
          c = d[i]
          a.x
        }
      }
    """

    describe "", ->
      testCase """
        for of
        ---
        "civet coffee-compat"
        for a of b
          console.log a
        ---
        var a
        for (a in b) {
          console.log(a)
        }
      """

      testCase """
        for own of
        ---
        "civet coffee-compat"
        for own a of b
          console.log a
        ---
        var a
        const hasProp: <T>(this: T, prop: keyof T) => boolean = {}.hasOwnProperty as any
        for (a in b) {
          if (!hasProp.call(b, a)) continue
          console.log(a)
        }
      """

      testCase """
        for own of postfix
        ---
        "civet coffee-compat"
        log(a) for own a of b when a != "y"
        ---
        var a
        const hasProp: <T>(this: T, prop: keyof T) => boolean = {}.hasOwnProperty as any
        for (a in b) {  if (!hasProp.call(b, a)) continue
          if (!(a !== "y")) continue
        log(a) }
      """

    testCase """
      for from
      ---
      "civet coffee-compat"
      for a from b
        console.log a
      ---
      var a
      for (a of b) {
        console.log(a)
      }
    """

    testCase """
      for from destructuring
      ---
      "civet coffee-compat"
      for {a, b} from c
        console.log a
      ---
      var a, b
      for ({a, b} of c) {
        console.log(a)
      }
    """

  describe "not", ->
    testCase """
      not
      ---
      "civet coffee-compat"
      not a
      ---
      !a
    """

    testCase """
      coffeeNot
      ---
      "civet coffeeNot"
      not a
      ---
      !a
    """

    testCase """
      non-compat
      ---
      not a
      ---
      not(a)
    """

  describe "auto-var", ->
    testCase """
      multiple assignment
      ---
      "civet auto-var"
      a = b = c = d
      a = 2
      ---
      var a, b, c
      a = b = c = d
      a = 2
    """

    testCase """
      assignment to variable indexed array
      ---
      "civet auto-var"
      a[x] = 1
      ---
      a[x] = 1
    """

    testCase """
      with a declaration
      ---
      "civet auto-var"
      let b = 2
      a = 1
      b = a
      ---
      var a
      let b = 2
      a = 1
      b = a
    """

    testCase """
      with a var declaration
      ---
      "civet auto-var"
      var b = 2
      a = 1
      b = a
      ---
      var a
      var b = 2
      a = 1
      b = a
    """

    testCase """
      with a binding pattern
      ---
      "civet auto-var"
      let [a, b] = [1, 2]
      a = 3
      ---
      let [a, b] = [1, 2]
      a = 3
    """

    testCase """
      with import named binding
      ---
      "civet auto-var"
      import {a, b} from 'c'
      a = 1
      ---
      import {a, b} from 'c'
      a = 1
    """

    testCase """
      with default import
      ---
      "civet auto-var"
      import a from 'b'
      a = 1
      ---
      import a from 'b'
      a = 1
    """

    testCase """
      with default and named import
      ---
      "civet auto-var"
      import a, {b, c} from 'd'
      a = 1
      b = 2
      ---
      import a, {b, c} from 'd'
      a = 1
      b = 2
    """

    testCase """
      with an array destructuring assignment
      ---
      "civet auto-var"
      [a, b] = [1, 2]
      ---
      var a, b
      [a, b] = [1, 2]
    """

    testCase """
      with nested array destructuring assignment
      ---
      "civet auto-var"
      [
        a
        b
      ] = [1, 2]
      ---
      var a, b
      [
        a,
        b
      ] = [1, 2]
    """

    testCase """
      with an object destructuring assignment
      ---
      "civet auto-var"
      {a, b} = {a: 1, b: 2}
      ---
      var a, b
      ({a, b} = {a: 1, b: 2})
    """

    testCase """
      with nested object destructuring assignment
      ---
      "civet auto-var"
      {
        a
        b
      } = {a: 1, b: 2}
      ---
      var a, b
      ({
        a,
        b
      } = {a: 1, b: 2})
    """

    testCase """
      with destructuring assignment renaming
      ---
      "civet auto-var"
      {a: b, c: d} = {a: 1, c: 2}
      ---
      var b, d
      ({a: b, c: d} = {a: 1, c: 2})
    """

    testCase """
      with destructuring assignment nested renaming
      ---
      "civet auto-var"
      {
        a: {b: c}
        d: e
      } = {a: 1, c: 2}
      ---
      var c, e
      ({
        a: {b: c},
        d: e
      } = {a: 1, c: 2})
    """

    testCase """
      with destructuring assignment object in array in object
      ---
      "civet auto-var"
      {
        a: [b, {c}]
        d: e
      } = {a: 1, c: 2}
      ---
      var b, c, e
      ({
        a: [b, {c}],
        d: e
      } = {a: 1, c: 2})
    """

    testCase """
      for i loop
      ---
      "civet auto-var"
      for i = 0; i < 10; i++
        a = i
      ---
      var i, a
      for (i = 0; i < 10; i++) {
        a = i
      }
    """

    testCase """
      for in loop with let dec
      ---
      "civet auto-var"
      for let a in b
        a = c = 1
      ---
      var c
      for (let a in b) {
        a = c = 1
      }
    """

    testCase """
      for loop implied const
      ---
      "civet auto-var"
      for a in b
        a = c = 1
      ---
      var c
      for (const a in b) {
        a = c = 1
      }
    """

    testCase """
      chained assignment
      ---
      "civet auto-var"
      a = b = c = 1
      ---
      var a, b, c
      a = b = c = 1
    """

    testCase """
      chained assignment with a declaration
      ---
      "civet auto-var"
      let a = 1
      a = b = c = 1
      ---
      var b, c
      let a = 1
      a = b = c = 1
    """

    testCase """
      chained assignment with destructuring
      ---
      "civet auto-var"
      {a, b} = c = d
      ---
      var a, b, c
      ({a, b} = c = d)
    """

    testCase """
      chained assignment with destructuring in other order
      ---
      "civet auto-var"
      a = {b, c} = d
      ---
      var a, b, c
      a = ({b, c} = d)
    """

    testCase """
      chained assignment with destructuring and a declaration
      ---
      "civet auto-var"
      let a = 1
      {a, b} = c = d
      ---
      var b, c
      let a = 1
      ({a, b} = c = d)
    """

    testCase """
      multiple chained destructuring assignments
      ---
      "civet auto-var"
      {a, b} = {c, d} = x
      ---
      var a, b, c, d
      ({a, b} = {c, d} = x)
    """

    testCase """
      nested function
      ---
      "civet auto-var"
      x = 1
      a = ->
        x = 2
        y = 1
        b = ->
          x = 3
          y = 2
          z = 1
      ---
      var x, a
      x = 1
      a = function() {
        var y, b
        x = 2
        y = 1
        return b = function() {
          var z
          x = 3
          y = 2
          return z = 1
        }
      }
    """

    testCase """
      function with parameters
      ---
      "civet auto-var"
      a = (b, c) ->
        x = 1
        c = 2
      ---
      var a
      a = function(b, c) {
        var x
        x = 1
        return c = 2
      }
    """

    testCase """
      nested blocks
      ---
      "civet auto-var"
      x = 1
      {
        x = 2
        y = 1
        {
          x = 3
          y = 2
          z = 1
        }
        {
          z = 2
        }
      }
      ---
      var x, y, z
      x = 1
      {
        x = 2
        y = 1
        {
          x = 3
          y = 2
          z = 1
        }
        {
          z = 2
        }
      }
    """

  describe "coffee do", ->
    testCase """
      it invokes
      ---
      "civet coffeeDo"
      do x
      ---
      (x)()
    """

    testCase """
      invoke inline function
      ---
      "civet coffeeDo"
      do ->
        x = 1
      ---
      (function() {
        return x = 1
      })()
    """

    // https://coffeescript.org/#try:do%20x%20%3D%20y
    testCase """
      binds lower than assignment
      ---
      "civet coffeeDo"
      do x = y
      ---
      (x = y)()
    """

    // https://coffeescript.org/#try:do%20x%20%2B%20y
    testCase """
      it binds tighter than binary ops
      ---
      "civet coffeeDo"
      do x + y
      ---
      (x)() + y
    """
