Hera from ../source/parser.hera
{parse} := Hera

gen from ../source/generate.coffee
assert from assert

{ writeFileSync } from fs

{prune} := gen

verbose := false
displayAST := false
cache := false

compare := (src: string, result: string, filename: string) ->
  let events

  stack := []
  logs := []

  if cache
    caches := new Map

    events =
      enter: (ruleName, state) ->
        debugger
        let cache = caches.get(ruleName)
        if cache
          if cache.has(state.pos)
            // emoji money bag
            arrow := '💰'
            logs.push "".padStart(stack.length * 2, " ") + arrow + "   " + ruleName + ":" + state.pos
            return {
              cache: cache.get(state.pos)
            }

        arrow := String.fromCharCode(0x27A1)
        logs.push "".padStart(stack.length * 2, " ") + arrow + "   " + ruleName + ":" + state.pos
        stack.push ruleName
        return

      exit: (ruleName, state, result) ->
        let cache = caches.get(ruleName)
        if !cache
          cache = new Map
          caches.set(ruleName, cache)
        cache.set(state.pos, result)

        // emoji check mark or cross mark based on result
        mark := result ? "✅" : "❌"
        leftArrow := String.fromCharCode(0x2B05)

        stack.pop()
        logs.push "".padStart(stack.length * 2, " ") + leftArrow + " " + mark + ruleName + ":" + state.pos
        return

  ast := prune parse(src, {filename, events})
  if cache
    writeFileSync "parse00.log", logs.join("\n")
  if displayAST
    console.dir ast, {depth: null}

  assert.equal gen(ast, {}), result

testCase := (text: string) ->
  [desc, src, result] := text.split("\n---\n")

  it desc, ->
    compare src, result, desc

throws := (text: string) ->
  assert.throws ->
    gen(parse(text))

export {
  compare
  testCase
  throws
}
