import assert from "assert"
import ts from "typescript"

describe.skip "ts stuff", ->
  it "should parse tsconfig", ->
    tsConfigPath := "tsconfig.json"
    { config } := ts.readConfigFile(tsConfigPath, ts.sys.readFile)

    currentProjectPath := "./"

    existingOptions := {}

    config2 := ts.parseJsonConfigFileContent(
      config,
      ts.sys,
      currentProjectPath,
      existingOptions,
      tsConfigPath,
      undefined,
      [{
        extension: "civet",
        isMixedContent: false,
        // Note: in order for parsed config to include *.ext files, scriptKind must be set to Deferred.
        // See: https://github.com/microsoft/TypeScript/blob/2106b07f22d6d8f2affe34b9869767fa5bc7a4d9/src/compiler/utilities.ts#L6356
        scriptKind: ts.ScriptKind.Deferred
      }]
    )

    // console.log config, config2

    host := ts.createCompilerHost(config2)
    service := ts.createLanguageService(host)

    console.log config2, host, service

    function doHover(doc: TextDocument, position: Position): Hover {
      const { scriptDoc: js_doc, service } = updateCurrentCoffeescriptTextDocument(coffee_doc);
      if (!languageServiceIncludesFile(service, coffee_doc.uri)) {
        return { contents: [] };
      }
      const fileFsPath = getFileFsPath(coffee_doc.uri);

      const transpilation = transpile_service.result_by_uri.get(coffee_doc.uri)
      if(!transpilation)
        return { contents: [] }

      if(transpilation.source_map)
        position = transpile_service.position_coffee_to_js(transpilation, position, coffee_doc) || position

      const info = service.getQuickInfoAtPosition(fileFsPath, js_doc.offsetAt(position));

      if (info) {
        const display = tsModule.displayPartsToString(info.displayParts);
        const markedContents: MarkedString[] = [{ language: 'ts', value: display }];

        let hoverMdDoc = '';
        const doc = Previewer.plain(tsModule.displayPartsToString(info.documentation));
        if (doc) {
          hoverMdDoc += doc + '\n\n';
        }

        if (info.tags) {
          info.tags.forEach(x => {
            const tagDoc = Previewer.getTagDocumentation(x);
            if (tagDoc) {
              hoverMdDoc += tagDoc + '\n\n';
            }
          });
        }

        if (hoverMdDoc.trim() !== '') {
          markedContents.push(hoverMdDoc);
        }

        let range = convertRange(js_doc, info.textSpan)
        if(transpilation.source_map)
          range = transpile_service.range_js_to_coffee(transpilation, range, coffee_doc) || range

        return {
          range,
          contents: markedContents
        };
      }
      return { contents: [] };
    }
